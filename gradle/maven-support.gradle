
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.w3c.dom.CharacterData;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource

import javax.xml.transform.OutputKeys
import javax.xml.transform.TransformerFactory
import javax.xml.transform.dom.DOMSource
import javax.xml.transform.stream.StreamResult;
import javax.crypto.Cipher
import javax.crypto.spec.SecretKeySpec
import java.lang.reflect.Method
import java.nio.file.Files
import java.nio.file.StandardCopyOption
import java.security.MessageDigest
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.FactoryConfigurationError;
import javax.xml.parsers.ParserConfigurationException;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

import org.w3c.dom.Document;
import org.w3c.dom.DOMException;

import java.io.*;

rootProject.ext.gradleFuryVersion = "1.1.2-SNAPSHOT"


/**=================================================================================================
 * Common Gradle script configuration for Maven tasks.
 *
 * @author Chris Doyle
 * @author Alex O'Ree
 =================================================================================================*/
buildscript {
    repositories {
        mavenCentral()
    }
}


apply plugin: 'maven'
apply plugin: 'maven-publish'


// Maven Repository (i.e. Sonatype Nexus Repository Manager) Configuration -------------------------

ext.isReleaseBuild = (!project.version.equals("unspecified") &&
        project.version.contains("SNAPSHOT") == false)


project.ext.artifacts = new LinkedList<Container>();
project.ext.pgpSearch =false;
project.ext.pgpAvailable=false;
project.ext.pomAdded=false;


def dumpTasks(TaskExecutionGraph graph){
    List<Task> allTasks = graph.getAllTasks();
    for (int i=0; i < allTasks.size(); i++){
        System.out.println("TASK DUMP " + allTasks.get(i).name);
    }

}

def furyHasTask(TaskExecutionGraph graph, String task){
    List<Task> allTasks = graph.getAllTasks();
    for (int i=0; i < allTasks.size(); i++){
        if (allTasks.get(i).name.endsWith(task))
            return true;
    }
    return false;

}




// another hack, import local.properties into the current context
// used for crypto settings
File local = new File("$rootDir/local.properties");
if (local.exists()){

    Properties properties = new Properties();
    properties.load(local.newDataInputStream());
    def iterator = properties.entrySet().iterator();
    while (iterator.hasNext()){

        def next = iterator.next();
        ext.set(next.getKey(), next.value);
    }

}



ext.gpgPath = (
        hasProperty('GPG_PATH')
                ? GPG_PATH
                : "/usr/local/bin/gpg"
        //TODO maybe a defaut path for windows?
);


ext.gpgPassphrase = (
        hasProperty('GPG_PASSPHRASE')
                ? GPG_PASSPHRASE
                : ""
);

if (mightBeEncrypted(ext.gpgPassphrase)){
    ext.gpgPassphrase=tryDecrypt(ext.gpgPassphrase);
}

ext.gpgPassphraseNew = (
        hasProperty('signing.passPhrase')
                ? project.property("signing.passPhrase")
                : ""
);

if (mightBeEncrypted(ext.gpgPassphraseNew)){
    ext.gpgPassphraseNew=tryDecrypt(ext.gpgPassphraseNew);
}

ext.gpgisInteractive = (
        hasProperty('signing.isInteractive')
                ? project.property("signing.isInteractive")
                : "true"
);
ext.gpgdefaultKeyring = (
        hasProperty('signing.defaultKeyring')
                ? project.property("signing.defaultKeyring")
                : "true"
);

ext.gpgKeyName = (
        hasProperty('signing.keyId')
                ? project.property("signing.keyId")
                : ""
);
ext.gpgKeyName = (
        hasProperty('signing.keyname')
                ? project.property("signing.keyname")
                : ""
);

ext.gpgHomeDir = (
        hasProperty('signing.homeDir')
                ? project.property("signing.homeDir")
                : ""
);
/*
not used in gpg2
ext.gpgUseAgent  = (
        hasProperty('signing.useAgent')
                ? project.property("signing.useAgent")
                : "true"
);
*/
project.ext.skipPublish = (
        hasProperty('skipPublish')
                ? project.property("skipPublish")
                : false
)
ext.gpgSecretKeyRingFile  = (
        hasProperty('signing.secretKeyRingFile')
                ? project.property("signing.secretKeyRingFile")
                : ""
);
ext.gpgPublicKeyring  = (
        hasProperty('signing.publicKeyring')
                ? project.property("signing.publicKeyring")
                : ""
);


// default to Maven Central if not provided
ext.releaseRepositoryUrl = (
        hasProperty('RELEASE_REPOSITORY_URL')
                ? RELEASE_REPOSITORY_URL
                : "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
)

// default to Maven Central if not provided
ext.snapshotRepositoryUrl = (
        hasProperty('SNAPSHOT_REPOSITORY_URL')
                ? SNAPSHOT_REPOSITORY_URL
                : "https://oss.sonatype.org/content/repositories/snapshots/"
)

ext.targetRepositoryUrl = ( isReleaseBuild ? releaseRepositoryUrl : snapshotRepositoryUrl)

ext.nexusUsername = ( hasProperty('NEXUS_USERNAME') ? NEXUS_USERNAME : "" )
ext.nexusPassword = ( hasProperty('NEXUS_PASSWORD') ? NEXUS_PASSWORD : "" )

if (mightBeEncrypted(ext.nexusPassword)){
    ext.nexusPassword=tryDecrypt(ext.nexusPassword);
}

if (hasProperty("android.signingConfigs.release.storePassword")){
    try {
        if (mightBeEncrypted(project.property("android.signingConfigs.release.storePassword"))) {
            project.setProperty("android.signingConfigs.release.storePassword", tryDecrypt(project.property("android.signingConfigs.release.storePassword")))
        }
    }catch (Exception ex){}
}
if (hasProperty("android.signingConfigs.release.keyPassword")){
    try{
    if (mightBeEncrypted(project.property("android.signingConfigs.release.keyPassword"))){
        project.setProperty("android.signingConfigs.release.keyPassword", tryDecrypt(project.property("android.signingConfigs.release.keyPassword")))
    }
    }catch (Exception ex){}
}



void printMOTD(){
    if (!rootProject.hasProperty('fury')) {
        rootProject.ext.fury = true;

        println "\n   ----.--.     #####                                        #######                     \n" +
                "--/ _  |___)  #     #  #####    ##   #####  #      ######    #       #    # #####  #   # \n" +
                "     \\_|____) #        #    #  #  #  #    # #      #         #       #    # #    #  # #  \n" +
                "       |____) #  ####  #    # #    # #    # #      #####     #####   #    # #    #   #   \n" +
                "---\\___(__)   #     #  #####  ###### #    # #      #         #       #    # #####    #   \n" +
                "               #    #  #   #  #    # #    # #      #         #       #    # #   #    #   \n" +
                "                #####  #    # #    # #####  ###### ######    #        ####  #    #   #   ";
        println "                                                                     v" + rootProject.ext.gradleFuryVersion + '\n';
        println "== Gradle Fury, bringing maven sensibility to gradle. It's NOT an incubating feature.";
        String[] MOTD = [
                "== Gradle Fury: ProTip: Use 'gradle.properties' to set all your version and pom related information.",
                "== Gradle Fury: ProTip: Use 'gradle install' to publish to mavenLocal, works with AARs and APKs, even with variants",
                "== Gradle Fury: ProTip: Use 'gradle install -Pprofile=javadoc' to generate javadocs (android included, even with variants",
                "== Gradle Fury: ProTip: Use 'gradle install -Pprofile=sources' to generate source jars (android included, even with variants",
                "== Gradle Fury: ProTip: Use 'gradle install -Pprofile=javadoc,sources' to generate javadocs and source jars (android included, even with variants",
                "== Gradle Fury: ProTip: For Android projects, apply gradle fury BEFORE the android{} block in your gradle.build file.",
                "== Gradle Fury: ProTip: Use 'gradle publishArtifacts' to publish to a nexus repository, works with AARs and APKs, even with variants",
                "== Gradle Fury: ProTip: Use 'gradle publishArtifacts -Pprofile=javadoc,source' to publish to a nexus repository with javadocs and sources",
                "== Gradle Fury: ProTip: Use 'gradle generateMasterKey' to make an encryption key",
                "== Gradle Fury: ProTip: Use 'gradle encryptPassword -PstoreField=NEXUS_PASSWORD' to encrypt your nexus password",
                "== Gradle Fury: ProTip: Use 'gradle install -Pprofile=ci' to build with all the code quality and analysis plugins",
                "== Gradle Fury: ProTip: Use 'gradle site' to build a maven style site that wraps up all your stuff with one bow",
                "== Gradle Fury: ProTip: Use 'gradle siteWar' to build a maven style site as a WAR file",
                "== Gradle Fury: ProTip: When using gradle 2.2.1 or older, include distZip when running install",
                "== Gradle Tip: Use 'gradle build -x test' to build and skip tests"
        ]


        Random r = new Random();
        int index = r.nextInt(MOTD.length);
        println MOTD[index];

        println "== Report Gradle Fury issues to: https://github.com/gradle-fury/gradle-fury/issues, also see the wiki for more info"
        println "\n Building version " + project.version + " of your project...";

    }
}




// Maven POM Properties ----------------------------------------------------------------------------

// The following property definitions are consumed by the maven-publish plugin to drive automatic
// Maven POM generation. The associated configuration properties should be defined in the standard
// gradle.properties file in the root of the project.  These standard properties have been
// purposefully externalized to allow for configuration on a per-project basis without requiring
// modification to this script.
//
// NOTE: Ultimately, this work should be refactored and cleaned up for inclusion into an existing or
// new formal Gradle plugin!  (A "labor of love" task for another day on my own time...)

def licenses = []

// parse the license list
if (hasProperty("pom.licenses.license.0.name")) {

    // parse the roles of each license
    for (def i = 0; hasProperty("pom.licenses.license.${i}.name"); ++i) {

        def license = [
                name: project.property("pom.licenses.license.${i}.name"),
                url         : (
                        hasProperty("pom.licenses.license.${i}.url")
                                ? project.property("pom.licenses.license.${i}.url") : ""
                ),
                distribution: (
                        hasProperty("pom.licenses.license.${i}.distribution")
                                ? project.property("pom.licenses.license.${i}.distribution") : ""
                )
        ]

        licenses[i] = license
    }
}

def developers = []

// parse the developer list
if (hasProperty("pom.developers.developer.0.id")) {

    // parse the roles of each developer
    for (def i = 0; hasProperty("pom.developers.developer.${i}.id"); ++i) {

        def roles = []

        if (hasProperty("pom.developers.developer.${i}.role.0")) {
            for (def j = 0; hasProperty("pom.developers.developer.${i}.role.${j}"); ++j) {
                roles[j] = project.property("pom.developers.developer.${i}.role.${j}")
            }
        }

        def developer = [
                id: project.property("pom.developers.developer.${i}.id"),
                name: (
                        hasProperty("pom.developers.developer.${i}.name")
                                ? project.property("pom.developers.developer.${i}.name") : ""
                ),
                email: (
                        hasProperty("pom.developers.developer.${i}.email")
                                ? project.property("pom.developers.developer.${i}.email") : ""
                ),
                organization: (
                        hasProperty("pom.developers.developer.${i}.organization")
                                ? project.property("pom.developers.developer.${i}.organization") : ""
                ),
                roles: roles
        ]

        developers[i] = developer
    }
}


// now we define the primary "pom" configuration used by the maven-publish plugin (see below)
ext.pom = [
        packaging: ( hasProperty('pom.packaging') ? project.property('pom.packaging') : "jar" ), // use JAR as the default ???
        name: ( hasProperty('project.name') ? project.property('project.name') : "" ),
        description: ( hasProperty('project.description') ? project.property('project.description') : "" ),
        url: ( hasProperty('pom.url') ? project.property('pom.url') : "http://TBD" ),
        inceptionYear: ( hasProperty('pom.inceptionYear') ? project.property('pom.inceptionYear') : "" ),
        licenses: licenses,
        organization: [
                name: ( hasProperty('pom.organization.name') ? project.property('pom.organization.name') : "" ),
                url: ( hasProperty('pom.organization.url') ? project.property('pom.organization.url') : "" )
        ],
        developers: developers,
        issueManagement: [
                system: (
                        hasProperty('pom.issueManagement.system') ? project.property('pom.issueManagement.system') : ""
                ),
                url: ( hasProperty('pom.issueManagement.url') ? project.property('pom.issueManagement.url') : "" )
        ],
        ciManagement: [
                system: ( hasProperty('pom.ciManagement.system') ? project.property('pom.ciManagement.system') : "" ),
                url: ( hasProperty('pom.ciManagement.url') ? project.property('pom.ciManagement.url') : "" )
        ],
        scm: [
                url: ( hasProperty('pom.scm.url') ? project.property('pom.scm.url') : "" ),
                connection: ( hasProperty('pom.scm.connection') ? project.property('pom.scm.connection') : "" ),
                developerConnection: (
                        hasProperty('pom.scm.developerConnection')
                                ? project.property('pom.scm.developerConnection') : ""
                )
        ],
        distributionManagement: [
                site: [
                        id: (
                                hasProperty('pom.distributionManagement.site.id')
                                        ? project.property('pom.distributionManagement.site.id') : ""
                        ),
                        url: ( hasProperty('pom.distributionManagement.site.url')
                                ? project.property('pom.distributionManagement.site.url') : ""
                        )
                ]
        ]
]


// Gradle Execution Pipeline Hacks -----------------------------------------------------------------

// And here's where we muck with the Gradle task execution pipeline in order to strong-arm the
// proper publishing of all artifacts (for every Android build variant) to a target Maven repository
// (e.g. Sonatype Nexus)
//
// For background information regarding this "neat" series of hacks, please visit the following
// thread from the Gradle forums:
//
//     "How can I upload multiple flavors/artifacts with different POM-files using mavenDeployer?"
//     https://discuss.gradle.org/t/how-can-i-upload-multiple-flavors-artifacts-with-different-pom-files-using-mavendeployer/5887
try {
    build.mustRunAfter clean
    publish.dependsOn build
    uploadArchives.dependsOn publish
    publishArtifacts.dependsOn build

}catch (Throwable t){
    logger.debug("failed to attach build and publish on project" + project.name, t);
}
uploadArchives {
    doFirst {
        //execution phase
        println "\n\n========================================================="
        println "==> WARNING: The 'uploadArchives' task is deprecated. <=="
        println "==> Calling the 'publish' task instead...             <=="
        println "=========================================================\n\n"

        throw new StopExecutionException("Calling the 'publish' task instead...")
    }
}

afterEvaluate { project ->

    printMOTD();


    project.ext.isJavaProject = project.plugins.hasPlugin('java');
    project.ext.isDistribution = project.plugins.hasPlugin('distribution') ||project.plugins.hasPlugin('application');
    project.ext.isWarProject = project.plugins.hasPlugin('war');


    // FIXME :: @chrisdoyle :: DRY :: these are also defined in android-support.gradle...
    project.ext.isAndroidApplication = project.plugins.hasPlugin("com.android.application");
    project.ext.isAndroidLibrary = project.plugins.hasPlugin("com.android.library");
    project.ext.isAndroidProject = project.isAndroidApplication || project.isAndroidLibrary;


    // Digitally sign all Release artifacts --------------------------------------------------------

    // NOTE: For now the only "validation" we will perform is whether or not a value is provided for
    // each of the required signingConfigs properties.  More concrete validation may be developed as
    // an enhancement in the future, if desired.
    ext.canSign = project.hasProperty('android.signingConfigs.release.storeFile') &&
            (project.property('android.signingConfigs.release.storeFile') != null) &&
            !project.property('android.signingConfigs.release.storeFile').trim().isEmpty() &&
            project.hasProperty('android.signingConfigs.release.storePassword') &&
            (project.property('android.signingConfigs.release.storePassword') != null) &&
            !project.property('android.signingConfigs.release.storePassword').trim().isEmpty() &&
            project.hasProperty('android.signingConfigs.release.keyAlias') &&
            (project.property('android.signingConfigs.release.keyAlias') != null) &&
            !project.property('android.signingConfigs.release.keyAlias').trim().isEmpty() &&
            project.hasProperty('android.signingConfigs.release.keyPassword') &&
            (project.property('android.signingConfigs.release.keyPassword') != null) &&
            !project.property('android.signingConfigs.release.keyPassword').trim().isEmpty();

    // END Digitally sign all Release artifacts ----------------------------------------------------


    // (Yet Another) Gradle Execution Pipeline Hack (to override the inoperable 'install' task for
    // Android projects!!!
    if (project.ext.isJavaProject || project.ext.isWarProject) {
        install {
            doFirst {
                println "\n\n========================================================="
                println "==> WARNING: The 'install' task is deprecated.        <=="
                println "==> Calling the 'publishToMavenLocal' task instead... <=="
                println "=========================================================\n\n"

                throw new StopExecutionException("Calling the 'publishToMavenLocal' task instead...")
            }
        }

        install.dependsOn build
        install.dependsOn publishToMavenLocal
        build.mustRunAfter clean
        publishToMavenLocal.dependsOn build
    }
    else if (project.ext.isAndroidProject) {
        task install() {
            doFirst {
                println "\n\n========================================================="
                println "==> WARNING: The 'install' task is deprecated.        <=="
                println "==> Calling the 'publishToMavenLocal' task instead... <=="
                println "=========================================================\n\n"

                throw new StopExecutionException("Calling the 'publishToMavenLocal' task instead...")
            }
        }

        install.dependsOn publishToMavenLocal

        build.mustRunAfter clean
        publishToMavenLocal.dependsOn build
    } else if (project.ext.isDistribution && !project.ext.isJavaProject){
        //distro only project
        task install() {

        }

        distZip.mustRunAfter clean
        publishToMavenLocal.dependsOn distZip
        install.dependsOn publishToMavenLocal
        install.mustRunAfter distZip
        install.finalizedBy installDistZipPom
    }

    if (project.hasProperty('profile')) {
        project.ext.profiles = project.profile.split(',')

        project.ext.set("ciProfileEnabled", project.ext.profiles.contains("ci"));

        project.ext.set("javadocProfileEnabled", project.ext.profiles.contains("javadoc")
                || project.ext.profiles.contains("javadocs") //for typos
                || project.ciProfileEnabled);

        project.ext.set("sourcesProfileEnabled", project.ext.profiles.contains("sources")
                || project.ext.profiles.contains("source")  //for typos
                || project.ciProfileEnabled);
    }
    else {
        project.ext.set("ciProfileEnabled", false);
        project.ext.set("javadocProfileEnabled", false);
        project.ext.set("sourcesProfileEnabled", false);
    }

    logger.info(":Javadocs enabled [" + project.javadocProfileEnabled + "]\t"+project.name)
    logger.info(":Sources enabled [" + project.sourcesProfileEnabled + "]\t"+project.name)
    logger.info(":CI enabled [" + project.ciProfileEnabled + "]\t"+project.name)

    if (project.isJavaProject) {
        if (project.javadocProfileEnabled) {
            javadoc {
                classpath = configurations.compile

                options.charSet 'UTF-8'
                options.docEncoding 'UTF-8'
                options.encoding 'UTF-8'
                //options.addStringOption('Xdoclint:none', '-quiet')
                //classpath = files(variant.javaCompile.classpath.files) + files(ext.androidJar)
                failOnError false

                if (hasProperty('compileJava.sourceCompatibility') &&
                        project.property("compileJava.sourceCompatibility").equals("1.5")) {
                    options.links 'http://java.sun.com/j2se/1.5.0/docs/guide/javadoc/doclet/spec'
                    options.links 'http://java.sun.com/j2se/1.5/docs/api/'
                } else if (hasProperty('compileJava.sourceCompatibility') &&
                        project.property("compileJava.sourceCompatibility").equals("1.6")) {
                    options.links 'http://docs.oracle.com/javase/6/docs/api/'
                } else if (hasProperty('compileJava.sourceCompatibility') &&
                        project.property("compileJava.sourceCompatibility").equals("1.7")) {
                    options.links 'http://docs.oracle.com/javase/7/docs/api/'
                } else if (hasProperty('compileJava.sourceCompatibility') &&
                        project.property("compileJava.sourceCompatibility").equals("1.8")) {
                    options.links 'http://docs.oracle.com/javase/8/docs/api/'
                }


                if (isGraphvizDotAvailable()) {

                    options {
                        doclet = 'org.umlgraph.doclet.UmlGraphDoc'
                        options.docletpath = configurations.umljavadoc.files.asType(List)
                        //looks like all of these settings are NOT passed to the doclet because of gradle.
                        //https://discuss.gradle.org/t/add-custom-javadoc-option-that-does-not-take-an-argument/5959/5
                        addStringOption('-inferrel')
                        addStringOption('-inferdep')
                        addStringOption('-qualify')
                        addStringOption('-postfixpackage')
                        addStringOption('-hide=java.*')
                        addStringOption('-collpackages=java.util.*')
                        addStringOption('-nodefontsize=9')
                        addStringOption('-nodefontpackagesize=7')
                    }
                }
                options {
                    setMemberLevel(JavadocMemberLevel.PACKAGE)
                }
            }

            task javadocJarPrep(dependsOn: javadoc) {
                File f = new File(project.buildDir.absolutePath + "/../src/main/java");
                if (f.exists()){
                    copy {
                        from f.absolutePath
                        into "$project.buildDir/docs/javadoc/"
                        include "**/doc-files/*"
                    }
                }
            }

            task javadocJar(type: Jar, dependsOn: [javadoc,javadocJarPrep]) {
                classifier = 'javadoc'
                from javadoc.destinationDir
            }
        }

        if (project.sourcesProfileEnabled) {
            task sourcesJar(type: Jar, dependsOn: classes) {
                classifier = 'sources'
                from sourceSets.main.allSource
            }
        }
    }
    else if (project.isAndroidProject) {
        def variants

        if (project.android.hasProperty('libraryVariants')) {
            variants = project.android.libraryVariants;
        }
        else if (project.android.hasProperty('applicationVariants')) {
            variants = project.android.applicationVariants;
        }

        variants.all { variant ->
            def artifactName = project.name + "-" + project.version + "-" + variant.name + "." +
                    project.pom.packaging;

            if (project.javadocProfileEnabled) {
                project.task("${variant.name}Javadoc", type: Javadoc) {
                    description "Generates Javadoc for $variant.name."
                    // https://github.com/chrisbanes/gradle-mvn-push/issues/9
                    failOnError false

                    destinationDir = new File("$project.buildDir/javadoc/$variant.name")

                    //reflect(project.android.sourceSets.main)
                    //source = projectDir.absolutePath + "/src/main/java/"
                    source = variant.javaCompile.source


                    String csdk = "${project.android.compileSdkVersion}";
                    if (csdk.contains("Google")){
                        try {
                            csdk = csdk.split(":")[2];
                        }catch (Exception ex){}
                    }

                    ext.androidJar =
                            "${android.sdkDirectory}/platforms/android-" + csdk + "/android.jar"

                    classpath = project.files(variant.javaCompile.classpath.files)
                    classpath += project.files(ext.androidJar)
                    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
                    //-bootclasspath /path/to/sdk/platforms/android-##/android.jar
                    // other lame attempts to overcome the 3-headed monster...
//                      classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
//                      classpath += variants.toList().first().javaCompile.classpath

                    if (hasProperty('compileJava.sourceCompatibility') &&
                            project.property("compileJava.sourceCompatibility").equals("1.5")) {
                        options.links 'http://java.sun.com/j2se/1.5.0/docs/guide/javadoc/doclet/spec'
                        options.links 'http://java.sun.com/j2se/1.5/docs/api/'
                    } else if (hasProperty('compileJava.sourceCompatibility') &&
                            project.property("compileJava.sourceCompatibility").equals("1.6")) {
                        options.links 'http://docs.oracle.com/javase/6/docs/api/'
                    } else if (hasProperty('compileJava.sourceCompatibility') &&
                            project.property("compileJava.sourceCompatibility").equals("1.7")) {
                        options.links 'http://docs.oracle.com/javase/7/docs/api/'
                    } else if (hasProperty('compileJava.sourceCompatibility') &&
                            project.property("compileJava.sourceCompatibility").equals("1.8")) {
                        options.links 'http://docs.oracle.com/javase/8/docs/api/'
                    }
                    options {
                        linksOffline("http://d.android.com/reference",
                                "${project.android.sdkDirectory}/docs/reference")
                        setMemberLevel(JavadocMemberLevel.PACKAGE)
                        docEncoding = 'UTF-8'
                        encoding = 'UTF-8'
                        charSet = 'UTF-8'
                    }
                    if (isGraphvizDotAvailable()) {

                        options {
                            doclet = 'org.umlgraph.doclet.UmlGraphDoc'
                            options.docletpath = configurations.umljavadoc.files.asType(List)
                            //looks like all of these settings are NOT passed to the doclet because of gradle.
                            //https://discuss.gradle.org/t/add-custom-javadoc-option-that-does-not-take-an-argument/5959/5
                            addStringOption('-inferrel')
                            addStringOption('-inferdep')
                            addStringOption('-qualify')
                            addStringOption('-postfixpackage')
                            addStringOption('-hide=java.*')
                            addStringOption('-collpackages=java.util.*')
                            addStringOption('-nodefontsize=9')
                            addStringOption('-nodefontpackagesize=7')

                        }
                    }

                    exclude '**/BuildConfig.java'
                    exclude '**/R.java'
                }

                project.task("generate${variant.name.capitalize()}JavadocJarCopy",
                        dependsOn: "${variant.name}Javadoc") {
                    description = 'Copies from src/doc-files for inclusion within javadocs, if it exists'

                    File f = new File(project.buildDir.absolutePath + "/../src/main/java");
                    if (f.exists()){
                        copy {
                            from f.absolutePath
                            into "$project.buildDir/javadoc/$variant.name/"
                            include "**/doc-files/*"
                        }
                    }
                    //and the variants
                    f = new File(project.buildDir.absolutePath + "/../src/$variant.name/java");
                    if (f.exists()){
                        copy {
                            from f.absolutePath
                            into "$project.buildDir/javadoc/$variant.name/"
                            include "**/doc-files/*"
                        }
                    }

                }

                project.task("generate${variant.name.capitalize()}JavadocJar", type: Jar,
                        dependsOn: ["${variant.name}Javadoc","generate${variant.name.capitalize()}JavadocJarCopy"]) {

                    classifier "${variant.name}-javadoc"

                    description = 'Assembles a JAR archive containing the generated Javadoc API documentation of $variant.name.'

                    exclude '**/BuildConfig.class'
                    exclude '**/R.class'

                    from "$project.buildDir/javadoc/$variant.name"
                }
            }

            if (project.sourcesProfileEnabled) {
                project.task("generate${variant.name.capitalize()}SourcesJar", type: Jar) {
                    classifier = "${variant.name}-sources"

                    description = 'Assembles a JAR archive containing the main sources of $variant.name.'

                    // exclude generated files
                    exclude '**/BuildConfig.java'
                    exclude '**/R.java'

                    from variant.javaCompile.source
                }
            }
        }
    }
}


def modifyGeneratedPom(pom) {


    File overrides = new File("${projectDir}/gradle.properties");
    if (overrides.exists()){
        logger.info("${projectDir}/gradle.properties exists, apply overrides");
        Properties props = new Properties();
        props.load(new FileInputStream("${projectDir}/gradle.properties"));
        props.each { prop ->
            project.ext.set(prop.key, prop.value)
        }
    }

    pom.withXml { provider ->
        def node = provider.asNode()

        System.out.println(":" + project.name + ":modifyGeneratedPomBecauseGradleIsTerrible");
        if (!project.pom.packaging.equals("")) {
            if (!node.packaging) {
                node.appendNode('packaging', project.pom.packaging)
            } else {
                node.packaging.replaceNode {
                    packaging(project.pom.packaging)
                }
            }
        } else {
            println "No pom.packaging defined in gradle.properties"
        }

        if (project.isAndroidProject || project.isWarProject || project.isJavaProject) {

            //fix for issue #27 name element missing from pom
            if ("".equals(project.pom.name)) {
                project.pom.name = project.getName();
            }

            if (!project.pom.name.equals("")) {
                if (!node.name) {
                    node.appendNode('name', project.pom.name)
                } else {
                    node.name.replaceNode {
                        name(project.pom.name)
                    }
                }
            }

            //fix for issue #27 description element missing from pom
            if ("".equals(project.pom.description)) {
                project.pom.description = project.getDescription();
            }
            //a description is mandatory for mavenCentral, this injects a placeholder
            if ("".equals(project.pom.description)) {
                project.pom.description = "A description should be added in the near future, as soon as I hack time.";
            }

            if (!project.pom.description.equals("")) {
                if (!node.description) {
                    node.appendNode('description', project.pom.description)
                } else {
                    node.description.replaceNode {
                        description(project.pom.description)
                    }
                }
            }

            //fix for issue #51 url element missing from pom
            //a URL is mandatory for mavenCentral, this injects a placeholder
            logger.debug("POM URL should be " + project.pom.url);
            if ("".equals(project.pom.url)) {
                project.pom.url = "http://TBD";
            }
            if (!node.url) {
                logger.debug("POM URL APPENDED");
                node.appendNode('url', project.pom.url)
            } else {
                logger.debug("POM URL REPLACE");
                node.url.replaceNode {
                    url(project.pom.url)
                }
            }
            logger.debug("POM URL IS NOW " + node.url);

            if (!project.pom.inceptionYear.equals("")) {
                if (!node.inceptionYear) {
                    node.appendNode('inceptionYear', project.pom.inceptionYear)
                } else {
                    node.inceptionYear.replaceNode {
                        inceptionYear(project.pom.inceptionYear)
                    }
                }
            }



            def repositoriesNode = node.appendNode("repositories")
            project.repositories.each {
                if (it.hasProperty("url") && it.url!=null && !it.url.toString().startsWith("file:/")) {
                    def repoNode = repositoriesNode.appendNode("repository")
                    repoNode.appendNode("id", it.name);
                    repoNode.appendNode("name", it.name);
                    repoNode.appendNode("url", it.url);
                }
            }

            def licenses = project.pom.licenses

            if ((licenses != null) && (licenses.size() > 0)) {
                def licensesNode = node.appendNode('licenses')

                licenses.each {
                    def licenseNode = licensesNode.appendNode('license')

                    if ((it.name != null) && !it.name.equals("")) {
                        licenseNode.appendNode('name', it.name)
                    }

                    if ((it.url != null) && !it.url.equals("")) {
                        licenseNode.appendNode('url', it.url)
                    }

                    if ((it.distribution != null) && !it.distribution.equals("")) {
                        licenseNode.appendNode('distribution', it.distribution)
                    }
                }
            }

            if (!project.pom.organization.name.equals("") || !project.pom.organization.url.equals("")) {
                def organizationNode = node.appendNode('organization')

                if (!project.pom.organization.name.equals("")) {
                    organizationNode.appendNode('name', project.pom.organization.name)
                }

                if (!project.pom.organization.url.equals("")) {
                    organizationNode.appendNode('url', project.pom.organization.url)
                }
            }


            def developers = project.pom.developers

            if ((developers != null) && (developers.size() > 0)) {
                def developersNode = node.appendNode('developers')

                developers.each {
                    def developerNode = developersNode.appendNode('developer')

                    if ((it.id != null) && !it.id.equals("")) {
                        developerNode.appendNode('id', it.id)
                    }

                    if ((it.name != null) && !it.name.equals("")) {
                        developerNode.appendNode('name', it.name)
                    }

                    if ((it.email != null) && !it.email.equals("")) {
                        developerNode.appendNode('email', it.email)
                    }

                    if ((it.organization != null) && !it.organization.equals("")) {
                        developerNode.appendNode('organization', it.organization)
                    }

                    if ((it.roles != null) && (it.roles.size() > 0)) {
                        def rolesNode = developerNode.appendNode('roles')
                        it.roles.each {
                            rolesNode.appendNode('role', it)
                        }
                    }
                }
            }

            if (!project.pom.issueManagement.system.equals("")
                    || !project.pom.issueManagement.url.equals("")) {

                def issueManagementNode = node.appendNode('issueManagement')

                if (!project.pom.issueManagement.system.equals("")) {
                    issueManagementNode.appendNode('system', project.pom.issueManagement.system)
                }
                if (!project.pom.issueManagement.url.equals("")) {
                    issueManagementNode.appendNode('url', project.pom.issueManagement.url)
                }
            }

            if (!project.pom.ciManagement.system.equals("")
                    || !project.pom.ciManagement.url.equals("")) {
                def ciManagementNode = node.appendNode('ciManagement')

                if (!project.pom.ciManagement.system.equals("")) {
                    ciManagementNode.appendNode('system', project.pom.ciManagement.system)
                }
                if (!project.pom.ciManagement.url.equals("")) {
                    ciManagementNode.appendNode('url', project.pom.ciManagement.url)
                }
            }

            if (!project.pom.scm.url.equals("") || !project.pom.scm.connection.equals("")
                    || !project.pom.scm.developerConnection.equals("")) {
                def scmNode = node.appendNode('scm')

                if (!project.pom.scm.url.equals("")) {
                    scmNode.appendNode('url', project.pom.scm.url)
                }
                if (!project.pom.scm.connection.equals("")) {
                    scmNode.appendNode('connection', project.pom.scm.connection)
                }
                if (!project.pom.scm.developerConnection.equals("")) {
                    scmNode.appendNode('developerConnection', project.pom.scm.developerConnection)
                }
            }

            if (!project.pom.distributionManagement.site.id.equals("")
                    || !project.pom.distributionManagement.site.url.equals("")) {
                def distributionManagementNode = node.appendNode('distributionManagement')
                def siteNode = distributionManagementNode.appendNode('site')

                if (!project.pom.distributionManagement.site.id.equals("")) {
                    siteNode.appendNode('id', project.pom.distributionManagement.site.id)
                }
                if (!project.pom.distributionManagement.site.url.equals("")) {
                    siteNode.appendNode('url', project.pom.distributionManagement.site.url)
                }
            }
            if (project.isAndroidProject || project.isWarProject  || project.isJavaProject) {

                //note to self. sticking || project.isJavaProject in this above if statement breaks
                //because it adds a SECOND dependencies node on the pom. why? no clue
                // modified from "Gradle not including dependencies in published pom.xml"
                // http://stackoverflow.com/a/32451846/3093897


                //fix for jar projects with multiple dependencies nodes
                //https://discuss.gradle.org/t/maven-publish-doesnt-include-dependencies-in-the-project-pom-file/8544/3?u=spy99
                def dependenciesNode = asNode().getAt("dependencies")[0]

                if (dependenciesNode==null) {
                    //no dependency node exists, add it
                    dependenciesNode = asNode().appendNode("dependencies")
                } else {
                    //probably a jar project, which gradle insists on adding a dependencies node
                    //purge the stuff gradle adds, since the scope is usually wrong anyhow
                    //http://docs.groovy-lang.org/latest/html/api/groovy/util/Node.html
                    dependenciesNode.children().clear()
                }
                def configurationNames;
                if (project.isAndroidProject)
                    configurationNames = ['default', 'compile', 'testCompile', 'androidTestCompile', 'provided'] // FIXME :: Issue #21: POM dependency generation shall support type and scope
                else {
                    configurationNames = ['compile', 'testCompile','compileOnly']
                    // FIXME :: Issue #21: POM dependency generation shall support type and scope
                }

                configurations.findAll { set ->
                    set.each { config ->
                        // Note to future self
                        // this apparently dumps all every jar/aar/war/etc file name of the dependency
                        //useful for #21 and getting the type. This was initially written to get a list
                        //of all configurationNames since they vary from android/jar/war projects
                        // System.out.println("CONFIG " +config.name);
                    }
                }
                int addedDependencies=0;

                //note to future self, gradle, when it comes to dependency managements in pom's
                //is generally terrible
                // for java projects
                //      as it doesn't respect exclusions
                //      type, scope, classifiers are ignored
                //for android projects
                //      all external dependencies are NOT included
                //      type, scope, classifiers are ignored

                //in addition, i wrote a huge chunk of code to prevent duplicate entries
                //why? because gradle appears to take the last entry as gospel whether or not it's
                //the highest in terms of importance

                //moreover, in my journey to dedup and fix scopes, i found that iterating over the
                //dependency list tends to wipe out anything that was added to the list. therefore making
                //adding an item, then deduplicating impossible with the built in stuff.

                //and that's how we ended up here, track the dependencies in our own structure
                //dedup on that list, then add them to the gradle pom structure.

                //this is our internal list for deduping dependencies
                List<Dependency> newDeps = new ArrayList<>();

                try {
                    //https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Scope
                    //maven only supports the following scope identifiers
                    //test, compile, provided, runtime, system,

                    //project.configurations.each { configuration ->
                        //def configurationName = configuration.name
                        configurationNames.each { configurationName ->
                        try {

                            logger.info("@@@@@@@ processing dependencies for " + configurationName)
                            //configuration.allDependencies.each { dependency ->
                            configurations[configurationName].allDependencies.each { dependency ->
                                if (dependency.group != null && dependency.name != null) {


                                    //logger.debug(dependency.to)
                                    String version;
                                    if (dependency.version.endsWith("+")) {
                                        //a gradle wildcard
                                        if ("+".equals(dependency.version)) {
                                            version = "LATEST"
                                        } else if (dependency.version.endsWith(".+")) {
                                            //the version is something.+
                                            version = "[" + dependency.version.replace(".+", ",)");
                                        } else if (dependency.version.endsWith("+")) {
                                            version = "[" + dependency.version.replace("+", ",)")
                                        } else {
                                            version = dependency.version;
                                            logger.warn("WARN - unhandled case for dependency version mediation for " +
                                                    dependency.group + ":" + dependency.name + ":" + dependency.version);
                                        }
                                        //TODO there may be other cases here

                                    } else {
                                        version = dependency.version;
                                    }

                                    String scope = "";
                                    if ("default".equalsIgnoreCase(configurationName) ||
                                            "compile".equalsIgnoreCase(configurationName) ||
                                            "releaseCompile".equalsIgnoreCase(configurationName))
                                        scope = "compile";
                                    else if ("testCompile".equalsIgnoreCase(configurationName) ||
                                            "androidTestCompile".equalsIgnoreCase(configurationName) ||
                                            configurationName.toLowerCase().contains("test"))
                                        scope = "test";
                                    else if ("compileOnly".equalsIgnoreCase(configurationName) ||
                                            "provided".equalsIgnoreCase(configurationName))
                                        scope = "provided";
                                    else if ("runtime".equalsIgnoreCase(configurationName))
                                        scope = "runtime";
                                    else scope = "compile";





                                    Dependency d = new Dependency();
                                    d.version=version;
                                    d.groupId=dependency.group;
                                    d.artifactId = dependency.name;
                                    d.scope = scope;
                                    //throws a silent exception d.type = dependency.type;
                                    if (configurationName.toLowerCase().contains("release")){
                                        //d.classifier = "release";
                                    }
                                    if (configurationName.toLowerCase().contains("debug")){
                                        //d.classifier = "debug";
                                    }
                                    // FIXME :: Issue #21: POM dependency generation shall support type and scope
                                    configurations.findAll { set ->
                                        set.each { config ->
                                           // System.out.println(config.name)
                                            if (config.name.contains(d.artifactId)){
                                                String extension=config.name.substring(config.name.lastIndexOf(".")+1);
                                                d.type=extension;
                                            }
                                        }
                                    }

                                    if (dependency.excludeRules.size() > 0) {
                                        dependency.excludeRules.each { rule ->
                                            Dependency exc = new Dependency();
                                            exc.groupId= rule.group;
                                            exc.artifactId=rule.module;
                                            if (rule.hasProperty("version"))    //maybe a future, non-incubation version of gradle will support this
                                                exc.version=rule.version
                                            d.exclusions.add(exc)
                                        }
                                    }

                                    logger.info("preparing dependency " + dependency.group + ":" + dependency.name + ":" + version + ":" + scope);

                                    //this bit checks for duplicate entries and upgrades the scope as needed
                                    boolean skipAdd=false;
                                    for (int i=0; i < newDeps.size(); i++){
                                        Dependency existing = newDeps.get(i);
                                        if (existing.groupId.equalsIgnoreCase(d.groupId) &&
                                                existing.artifactId.equalsIgnoreCase(d.artifactId) &&
                                                existing.version.equalsIgnoreCase(d.version)){
                                            skipAdd=true;
                                            if (existing.scope.equalsIgnoreCase("compile")){
                                                //do nothing, ignore the new one
                                            } else if (existing.scope.equalsIgnoreCase("test") &&
                                                    "compile".equalsIgnoreCase(d.scope)){
                                                //update
                                                existing.scope = "compile";
                                                logger.info("scope upgraded for " + existing);
                                            } else if (existing.scope.equalsIgnoreCase("provided") &&
                                                    "compile".equalsIgnoreCase(d.scope)){
                                                //update
                                                existing.scope = "compile";
                                                logger.info("scope upgraded for " + existing);
                                            } else if (existing.scope.equalsIgnoreCase("runtime") &&
                                                    "compile".equalsIgnoreCase(d.scope)){
                                                //update
                                                existing.scope = "compile";
                                                logger.info("scope upgraded for " + existing);
                                            } else{
                                                //old scope and new scope are the same
                                                //System.out.println("huh? existing is " + existing +" new dep is "+ d);
                                            }
                                        }
                                    }
                                    if (!skipAdd)
                                        newDeps.add(d);



                                   // System.out.println("dupchecker1" + scope)

                                    //duplicate check
                                    /*
                                    boolean dupFound = false;
                                    //reflect(dependenciesNode)
                                    boolean keepGoing = false;
                                    try {
                                        System.out.println("BEFORE");
                                        printCurrentDependency(asNode().getAt("dependencies")[0])
                                        dependenciesNode.each { item ->
                                            if (keepGoing) {

                                                //reflect(item);

                                                            The following code was left in memory for those hours
                                                            of time lost to this horrific build system.

                                                            there's no way to get the group/artifact etc
                                                            after it's been addeded, the only way to toString
                                                            then parse the string output.

                                                        System.out.println("dupchecker2 comparing " + item);
                                                        System.out.println(" vs "+ dependency)
                                                        System.out.println("3"+item.group.value);
                                                        System.out.println("4"+item.group);
                                                        System.out.println("5"+item.group['value']);

                                                        item.attributes.each { attr->
                                                            System.out.println("6"+ attr);
                                                        };
                                                        item.values.each { attr->
                                                            System.out.println("7"+ attr);
                                                        };
                                                        System.out.println("8"+item['group']);
                                                        //System.out.println("9"+item.getProperty('group'));

                                                //System.out.println("9" + item.getProperties().directChildren);
                                                //produces the following
                                                //9[groupId[attributes={}; value=org.apache.commons], artifactId[attributes={}; value=commons-lang3], version[attributes={}; value=3.4], scope[attributes={}; value=compile]]

                                                String itemscope = "compile";
                                                String itemgroup;
                                                String itemversion;
                                                String itemid;

                                                String crap = item.getProperties().directChildren;
                                                //gross
                                                int index = crap.indexOf("value=", crap.indexOf("groupId[["));
                                                if (index > 0) {
                                                    index += 5
                                                    itemgroup = crap.substring(index + 1, crap.indexOf("]", index));
                                                }

                                                index = crap.indexOf("value=", crap.indexOf("scope["));
                                                if (index > 0) {
                                                    index += 5
                                                    itemscope = crap.substring(index + 1, crap.indexOf("]", index));
                                                }
                                                index = crap.indexOf("value=", crap.indexOf("artifactId["));
                                                if (index > 0) {
                                                    index += 5
                                                    itemid = crap.substring(index + 1, crap.indexOf("]", index));
                                                }
                                                index = crap.indexOf("value=", crap.indexOf("version["));
                                                if (index > 0) {
                                                    index += 5
                                                    itemversion = crap.substring(index + 1, crap.indexOf("]", index));
                                                }

                                                System.out.println("comparing against " + itemgroup + ":" + itemid + ":" + itemversion + ":" + itemscope);

                                                //System.out.println("10"+item.getProperties().directChildren.getProperties()['groupId']);
                                                //reflect(item.getProperties().directChildren);

                                                //null System.out.println("91"+item.getProperties().directChildren.hasProperty('groupId'));

                                                //nopeSystem.out.println("10"+item.getProperties().directChildren.groupId);
                                                //10[]

                                                //nope System.out.println("11"+item.getProperties().directChildren.getProperty('groupId'));

                                                //nope System.out.println("12"+item.getProperties().directChildren['groupId']);
                                                //12[]

                                                //nope System.out.println("13"+item.getProperties().directChildren.getProperties());
                                                //13[class:class groovy.util.NodeList, empty:false]

                                                //System.out.println("5"+item.getName());
                                                //System.out.println("5"+item.getVersion());
                                                //item.group.each {->val
                                                //    System.out.println("6"+val);
                                                //};
                                                //System.out.println("7"+item.group.value());
                                                //System.out.println("8"+item.group.value.value());

                                                //item* is an existing item
                                                if (itemgroup.equalsIgnoreCase(dependency.group) &&
                                                        itemid.equalsIgnoreCase(dependency.name) &&
                                                        itemversion.equalsIgnoreCase(version)) {
                                                    //probable duplicate need to
                                                    System.out.println("\t\tFOUND dupchecker2" + item)
                                                    dupFound = true;

                                                    if (itemscope.equalsIgnoreCase("compile")) {
                                                        //do nothing
                                                        //existing item is already compile, don't change it or add a dup

                                                        System.out.println("skip, existing item is a compile dependency");
                                                    } else if (itemscope.equals("test") && !scope.equals("test")) {
                                                        //item.scope = scope;
                                                        System.out.println("######### scope replaced");
                                                        dupFound = false;
                                                        System.out.println("Before" + dependenciesNode.size());
                                                        //dependenciesNode.remove(item);
                                                        keepGoing = false;
                                                        System.out.println("after" + dependenciesNode.size());
                                                    } else if (itemscope.equals("provided") && scope.equals("compile")) {
                                                        //item.scope = scope;
                                                        System.out.println("######### scope replaced");
                                                        dupFound = false;
                                                        System.out.println("Before" + dependenciesNode.size());
                                                        //dependenciesNode.remove(item);
                                                        keepGoing = false;
                                                        System.out.println("after" + dependenciesNode.size());
                                                    } else {
                                                        //possible that the scopes are equal or greater than for the new node

                                                        //dependenciesNode.remove(item);
                                                    }

                                                }
                                            }
                                        }
                                    } catch (Throwable t) {
                                        t.printStackTrace()
                                    }

                                    if (false) {//!dupFound
                                        addedDependencies++;
                                        System.out.println("adding dependency " + dependency.group + ":" + dependency.name + ":" + version + ":" + scope);

                                        def dependencyNode = dependenciesNode.appendNode('dependency')
                                        dependencyNode.appendNode('groupId', dependency.group)
                                        dependencyNode.appendNode('artifactId', dependency.name)

                                        dependencyNode.appendNode('version', version)
                                        dependencyNode.appendNode('scope', scope);

                // FIXME :: Issue #21: POM dependency generation shall support type and scope
                //                        dependencyNode.appendNode('type', ???)
                //                        dependencyNode.appendNode('scope', configurationName) // ???

                                        // if there are any exclusions in dependency
                                        if (dependency.excludeRules.size() > 0) {
                                            def exclusionsNode = dependencyNode.appendNode('exclusions')
                                            dependency.excludeRules.each { rule ->
                                                def exclusionNode = exclusionsNode.appendNode('exclusion')
                                                exclusionNode.appendNode('groupId', rule.group)
                                                exclusionNode.appendNode('artifactId', rule.module)
                                            }
                                        }
                                    } else {
                                        logger.debug("skip dependency " + dependency.group + ":" + dependency.name + ":" + version + ":" + scope);
                                    }

                                    //System.out.println("AFTER");
                                    //printCurrentDependency(asNode().getAt("dependencies")[0])

                                     */
                                }
                            }
                        } catch (Exception ex) {
                            logger.info("Issue 119, swallowed exception requesting the config name " + configurationName, ex);
                            //fix for issue 119
                            //always possible that the requested configuration does not exist on this project,
                            //so skip it
                        }
                    }
                }catch (Throwable t){
                    logger.warn("Issue 144, unexpected error fixing pom for " + project.name, t);
                }

                //inject the deduped dependencies
                for (int i=0; i < newDeps.size(); i++){
                    Dependency dependency = newDeps.get(i);
                    addedDependencies++;
                    logger.info("adding dependency " + dependency);

                    def dependencyNode = dependenciesNode.appendNode('dependency')
                    dependencyNode.appendNode('groupId', dependency.groupId)
                    dependencyNode.appendNode('artifactId', dependency.artifactId)

                    dependencyNode.appendNode('scope', dependency.scope);
                    dependencyNode.appendNode('version', dependency.version)
                    if(dependency.classifier!=null && dependency.classifier.length()>0){
                        dependencyNode.appendNode('classifier', dependency.classifier)
                    }
                    if(dependency.type!=null && dependency.type.length()>0){
                        dependencyNode.appendNode('type', dependency.type)
                    }

                    if (!dependency.exclusions.isEmpty()) {
                        def exclusionsNode = dependencyNode.appendNode('exclusions')

                        for (int k = 0; k < dependency.exclusions.size(); k++) {
                            def exclusionNode = exclusionsNode.appendNode('exclusion')
                            if (dependency.exclusions.get(k).groupId!=null && dependency.exclusions.get(k).groupId.length()>0)
                                exclusionNode.appendNode('groupId', dependency.exclusions.get(k).groupId)
                            if (dependency.exclusions.get(k).artifactId!=null && dependency.exclusions.get(k).artifactId.length()>0)
                                exclusionNode.appendNode('artifactId', dependency.exclusions.get(k).artifactId)
                            if (dependency.exclusions.get(k).version!=null && dependency.exclusions.get(k).version.length()>0)
                                exclusionNode.appendNode('version', dependency.exclusions.get(k).version)
                        }
                    }

                }

                logger.info("added " + addedDependencies + " dependencies")
            }
            //reflect(pom);
        }
    }
}



class Dependency{
    String groupId;
    String artifactId;
    String version;
    String type;
    String classifier;
    String scope;
    List<Dependency> exclusions = new ArrayList<Dependency>();

    String toString(){
        return groupId+":"+artifactId+":"+version + ":" +type + ":" +classifier + ":"+scope;
    }

}

void printDependences(List<Dependency> deps){
    for (int i=0; i < deps.size(); i++){
        System.out.println(deps.get(i));
    }
}

// maven-publish Configuration (I love me some incubation!!!) --------------------------------------
//
// =====================================================================================
// ==> COMMENTARY: Gradle is wackadoodle. (Or perhaps it's just my understanding...) <==
// =====================================================================================
//
// In order to avoid:
//
//      > Cannot configure the 'publishing' extension after it has been accessed.
//
// I had to steal some voodoo from here:
//
//      http://stackoverflow.com/a/27066692/3093897
//
// I have a vague idea what it does, but at the end of the day I don't really care as long as it
// freaking works.  It is absurd having to write non-standard Groovy code to support standard
// lifecycle operations, the least of which is artifact publishing.
//
// --Doyle
//

//Note: this block fires BEFORE the taskGraph is ready :(
project.plugins.withType(MavenPublishPlugin) {
    project.extensions.configure PublishingExtension,
            new org.gradle.api.internal.ClosureBackedAction({

                publications {
                    //System.out.println(project.isDistribution.toString() + " " + project.isJavaProject.toString() + " " +project.isWarProject.toString() + " " + project.isAndroidProject.toString())
                    if (project.isDistribution && !project.isJavaProject) {
                        //System.out.println("prcocessing as zip" + project.name)
                        project.pom.packaging = 'zip'

                        //System.out.println("processing dist zip")
                        distributions(MavenPublication) {
                            groupId project.group
                            artifactId project.name
                            version project.version



                            //System.out.println("processing dist zip pom")
                            def artifactName = project.name + "-" + project.version + "." + project.pom.packaging;
                            def artifactRoot = "${buildDir}/distributions/"


                            //fun fact, gradle does generate poms for dist only packages except our
                            //modifyPom method just doesn't work. not sure why. gradle could be overridding it
                            //no idea why it would behavior differently than anything else

                            //here we manually reparse rootDir/gradle.properties for all the pom settings
                            //then create a pom on the fly and write it to disk
                            createPom("$buildDir/distributions/", "pom-default.xml")
                            //the pom
                            Container c = new Container();
                            c.buildDir = "${buildDir}";
                            c.fileName = artifactName;
                            c.fileNameAndPath = "$buildDir/distributions/pom-default.xml";
                            c.type = "pom";
                            project.ext.artifacts.add(c);
                            logger.debug("Adding " + "$buildDir/distributions/pom-default.xml" + " to artifact list");

                            //needed for local pom publishing
                            //artifact(c.fileNameAndPath) {
                              //  extension 'pom'
                            //}

                            //primary out

                            c = new Container();
                            c.buildDir = "${buildDir}";
                            c.fileName = artifactName;
                            c.fileNameAndPath = "${artifactRoot}${artifactName}";
                            c.type = "zip";
                            project.ext.artifacts.add(c);
                            logger.debug("Adding " + "${artifactRoot}${artifactName}" + " to artifact list");


                            //needed for local publishing
                            artifact("${artifactRoot}/${artifactName}") {
                                extension project.pom.packaging
                            }


                        }
                        //modifyGeneratedPom(pom)
                        //createPom("$buildDir/distributions/", "pom-default.xml")
                    }


                    if (project.isDistribution && project.isJavaProject) {
                        //System.out.println("prcocessing as jar AND zip " + project.name)
                        project.pom.packaging = 'jar'

                        //System.out.println("processing dist zip")
                        distributions(MavenPublication) {
                            groupId project.group
                            artifactId project.name
                            version project.version


                            //modifyGeneratedPom(pom)
                            //System.out.println("processing dist zip pom")
                            def artifactName = project.name + "-" + project.version + ".zip";
                            def artifactRoot = "${buildDir}/distributions/"


                            Container c ;



                            //primary out

                            c = new Container();
                            c.buildDir = "${buildDir}";
                            c.fileName = artifactName;
                            c.fileNameAndPath = "${artifactRoot}${artifactName}";
                            c.type = "zip";
                            project.ext.artifacts.add(c);
                            logger.debug("Adding " + "${artifactRoot}${artifactName}" + " to artifact list");


                            //needed for local publishing
                            artifact("${artifactRoot}/${artifactName}") {

                            }


                        }

                        //System.out.println("prcocessing as jar" + project.name)
                        project.pom.packaging = 'jar'
                        def artifactName = project.name + "-" + project.version + "." + project.pom.packaging;
                        def artifactRoot = "${buildDir}/libs/"

                        javaArtifacts(MavenPublication) {
                            from components.java

                            groupId project.group
                            artifactId project.name
                            version project.version

                            modifyGeneratedPom(pom)

                            //the jar
                            Container c;
                            c = new Container();
                            c.buildDir = "${buildDir}";
                            c.fileName = artifactName;
                            c.fileNameAndPath = "${artifactRoot}${artifactName}";
                            c.type = "jar";
                            project.ext.artifacts.add(c);
                            logger.debug("Adding " + "${artifactRoot}${artifactName}" + " to artifact list");


                            //the pom
                            c = new Container();
                            c.buildDir = "${buildDir}";
                            c.fileName = artifactName;
                            c.fileNameAndPath = "$buildDir/publications/javaArtifacts/pom-default.xml";
                            c.type = "jar";
                            project.ext.artifacts.add(c);
                            logger.debug("Adding " + "$buildDir/publications/javaArtifacts/pom-default.xml" + " to artifact list");

                        }

                        if (project.javadocProfileEnabled) {
                            javadocArtifacts(MavenPublication) {
                                from components.java

                                groupId project.group
                                artifactId project.name
                                version project.version

                                modifyGeneratedPom(pom)

                                artifact javadocJar


                                Container c;
                                c = new Container();
                                c.buildDir = "${buildDir}";
                                c.fileName = artifactName;
                                c.fileNameAndPath = "${buildDir}" + "/libs/" + project.name + "-" + project.version + "-javadoc.jar";
                                c.type = "jar";
                                project.ext.artifacts.add(c);
                                logger.debug("Adding " + "${buildDir}" + "/libs/" + project.name + "-" + project.version + "-javadoc.jar" + " to artifact list");

                            }
                        }

                        if (project.sourcesProfileEnabled) {
                            sourceJarArtifacts(MavenPublication) {
                                from components.java

                                groupId project.group
                                artifactId project.name
                                version project.version

                                modifyGeneratedPom(pom)

                                artifact sourcesJar

                                Container c;
                                c = new Container();
                                c.buildDir = "${buildDir}";
                                c.fileName = artifactName;
                                c.fileNameAndPath = "${buildDir}" + "/libs/" + project.name + "-" + project.version + "-sources.jar";
                                c.type = "jar";
                                project.ext.artifacts.add(c);
                                logger.debug("Adding " + "${buildDir}" + "/libs/" + project.name + "-" + project.version + "-sources.jar" + " to artifact list");

                            }
                        }
                    }   //jave and distribution

                    if (project.isWarProject) {
                        project.pom.packaging = 'war'

                        def artifactName = project.name + "-" + project.version + "." + project.pom.packaging;
                        def artifactRoot = "${buildDir}/libs/"

                        webApp(MavenPublication) {
                            from components.web

                            groupId project.group
                            artifactId project.name
                            version project.version

                            modifyGeneratedPom(pom)


                            //primary out
                            Container c;
                            c = new Container();
                            c.buildDir = "${buildDir}";
                            c.fileName = artifactName;
                            c.fileNameAndPath = "${artifactRoot}${artifactName}";
                            c.type = "war";
                            project.ext.artifacts.add(c);
                            logger.debug("Adding " + "${artifactRoot}${artifactName}" + " to artifact list");




                            //the pom
                            c = new Container();
                            c.buildDir = "${buildDir}";
                            c.fileName = artifactName;
                            c.fileNameAndPath = "$buildDir/publications/webApp/pom-default.xml";
                            c.type = "war";
                            project.ext.artifacts.add(c);
                            logger.debug("Adding " + "$buildDir/publications/webApp/pom-default.xml" + " to artifact list");



                        }
                        if (project.javadocProfileEnabled) {
                            javadocArtifacts(MavenPublication) {
                                from components.web

                                groupId project.group
                                artifactId project.name
                                version project.version

                                modifyGeneratedPom(pom)

                                artifact javadocJar

                                //#27 pgp signatures
                                Container c;
                                c = new Container();
                                c.buildDir = "${buildDir}";
                                c.fileName = artifactName;
                                c.fileNameAndPath = "${buildDir}" + "/libs/" + project.name + "-" + project.version + "-javadoc.jar";
                                c.type = "jar";
                                project.ext.artifacts.add(c);
                                logger.debug("Adding " + "${buildDir}" + "/libs/" + project.name + "-" + project.version + "-javadoc.jar" + " to artifact list");

                            }
                        }

                        if (project.sourcesProfileEnabled) {
                            sourceJarArtifacts(MavenPublication) {
                                from components.web

                                groupId project.group
                                artifactId project.name
                                version project.version

                                modifyGeneratedPom(pom)

                                artifact sourcesJar
                                //#27 pgp signatures

                                Container c;
                                c = new Container();
                                c.buildDir = "${buildDir}";
                                c.fileName = artifactName;
                                c.fileNameAndPath = "${buildDir}" + "/libs/" + project.name + "-" + project.version + "-sources.jar";
                                c.type = "jar";
                                project.ext.artifacts.add(c);
                                logger.debug("Adding " + "${buildDir}" + "/libs/" + project.name + "-" + project.version + "-sources.jar" + " to artifact list");


                            }
                        }

                    } else if (project.isJavaProject && !project.isDistribution) {

                       // System.out.println("prcocessing as jar" + project.name)
                        project.pom.packaging = 'jar'
                        def artifactName = project.name + "-" + project.version + "." + project.pom.packaging;
                        def artifactRoot = "${buildDir}/libs/"

                        javaArtifacts(MavenPublication) {
                            from components.java

                            groupId project.group
                            artifactId project.name
                            version project.version

                            modifyGeneratedPom(pom)

                            //the jar
                            Container c;
                            c = new Container();
                            c.buildDir = "${buildDir}";
                            c.fileName = artifactName;
                            c.fileNameAndPath = "${artifactRoot}${artifactName}";
                            c.type = "jar";
                            project.ext.artifacts.add(c);
                            logger.debug("Adding " + "${artifactRoot}${artifactName}" + " to artifact list");


                            //the pom
                            c = new Container();
                            c.buildDir = "${buildDir}";
                            c.fileName = artifactName;
                            c.fileNameAndPath = "$buildDir/publications/javaArtifacts/pom-default.xml";
                            c.type = "jar";
                            project.ext.artifacts.add(c);
                            logger.debug("Adding " + "$buildDir/publications/javaArtifacts/pom-default.xml" + " to artifact list");

                        }

                        if (project.javadocProfileEnabled) {
                            javadocArtifacts(MavenPublication) {
                                from components.java

                                groupId project.group
                                artifactId project.name
                                version project.version

                                modifyGeneratedPom(pom)

                                artifact javadocJar


                                Container c;
                                c = new Container();
                                c.buildDir = "${buildDir}";
                                c.fileName = artifactName;
                                c.fileNameAndPath = "${buildDir}" + "/libs/" + project.name + "-" + project.version + "-javadoc.jar";
                                c.type = "jar";
                                project.ext.artifacts.add(c);
                                logger.debug("Adding " + "${buildDir}" + "/libs/" + project.name + "-" + project.version + "-javadoc.jar" + " to artifact list");

                            }
                        }

                        if (project.sourcesProfileEnabled) {
                            sourceJarArtifacts(MavenPublication) {
                                from components.java

                                groupId project.group
                                artifactId project.name
                                version project.version

                                modifyGeneratedPom(pom)

                                artifact sourcesJar

                                Container c;
                                c = new Container();
                                c.buildDir = "${buildDir}";
                                c.fileName = artifactName;
                                c.fileNameAndPath = "${buildDir}" + "/libs/" + project.name + "-" + project.version + "-sources.jar";
                                c.type = "jar";
                                project.ext.artifacts.add(c);
                                logger.debug("Adding " + "${buildDir}" + "/libs/" + project.name + "-" + project.version + "-sources.jar" + " to artifact list");

                            }
                        }
                    } else if (project.isAndroidProject) {
                        def artifactRoot
                        def variants

                        if (project.android.hasProperty('applicationVariants')) {
                            artifactRoot = "${buildDir}/outputs/apk"
                            variants = project.android.applicationVariants;
                        } else if (project.android.hasProperty('libraryVariants')) {
                            artifactRoot = "${buildDir}/outputs/aar"
                            variants = project.android.libraryVariants;
                        }


                        androidArtifacts(MavenPublication) {
                            groupId project.group
                            artifactId project.name
                            version project.version

                            modifyGeneratedPom(pom)

                            variants.all { variant ->

                                logger.info("Processing " + project.name + ":" + variant.name)

                                if (!variant.name.toLowerCase().endsWith("release")
                                        || (variant.name.toLowerCase().endsWith("release") && canSign)) {

                                    def artifactName = project.name + "-" + project.version + "-" +
                                            variant.name + "." + project.pom.packaging;
                                    def artifactPrefix = project.name + "-" + project.version + "-" +
                                            variant.name;

                                    //signs the pom
                                    Container c;


                                    if (!project.ext.pomAdded) {
                                        //this check prevents failures because the pom is generated multiple times,
                                        //mostly because of variants and debug/release
                                        project.ext.pomAdded = true;


                                        c = new Container();
                                        c.fileName = variant.name + ".pom";
                                        c.fileNameAndPath = "${buildDir}/publications/androidArtifacts/pom-default.xml"
                                        c.buildDir = "${buildDir}";
                                        if (project.isAndroidApplication)
                                            c.type = "apk";
                                        else c.type = "aar";
                                        project.ext.artifacts.add(c);


                                    } else {
                                        logger.info("Skipping pom " + "${buildDir}/publications/androidArtifacts/pom-default.xml.asc" + " POM already added");
                                    }

                                    //signs the actual output
                                    c = new Container();
                                    if (project.isAndroidApplication)
                                        c.type = "apk";
                                    else c.type = "aar";
                                    c.buildDir = "${buildDir}";
                                    c.fileName = variant.name;
                                    c.fileNameAndPath = "${artifactRoot}/${artifactName}";
                                    project.ext.artifacts.add(c);


                                    //our actual artifact
                                    logger.debug("Adding " + "${artifactRoot}/${artifactName}" + " to artifact list");
                                    artifact("${artifactRoot}/${artifactName}") {
                                        classifier variant.name
                                        extension project.pom.packaging
                                    }







                                    if (project.javadocProfileEnabled) {
                                        artifact tasks["generate${variant.name.capitalize()}JavadocJar"]
                                        logger.debug("Adding " + "${buildDir}/libs/${artifactPrefix}-javadoc.jar" + " to artifact list");

                                        c = new Container();
                                        if (project.isAndroidApplication)
                                            c.type = "apk";
                                        else c.type = "aar";
                                        c.buildDir = "${buildDir}";
                                        c.fileName = variant.name;
                                        c.fileNameAndPath = "${buildDir}/libs/${artifactPrefix}-javadoc.jar";
                                        project.ext.artifacts.add(c);



                                    }

                                    if (project.sourcesProfileEnabled) {
                                        artifact tasks["generate${variant.name.capitalize()}SourcesJar"]
                                        logger.debug("Adding " + "${buildDir}/libs/${artifactPrefix}-sources.jar" + " to artifact list");

                                        c = new Container();
                                        if (project.isAndroidApplication)
                                            c.type = "apk";
                                        else c.type = "aar";
                                        c.buildDir = "${buildDir}";
                                        c.fileName = variant.name;
                                        c.fileNameAndPath = "${buildDir}/libs/${artifactPrefix}-sources.jar";
                                        project.ext.artifacts.add(c);

                                    }
                                } else if ((variant.name.toLowerCase().endsWith("release") && !canSign)) {
                                    logger.warn("====================\n\n" +
                                            "WARN You're perform a release build with android artifacts but have not specified signing certificate (JKS). Check gradle.properties\n\n" +
                                            "====================");
                                } else {
                                    //logger.warn("Not a release and I can't sign, most things are skipped");
                                }
                            }
                        }
                    }
                }

                if (!"".equalsIgnoreCase(project.targetRepositoryUrl)) {
                    repositories {
                        maven {
                            url project.targetRepositoryUrl

                            if (!project.nexusUsername.equals("")) {
                                credentials {
                                    username project.nexusUsername
                                    password project.nexusPassword
                                }
                            }
                        }
                    }
                }
            })
}



//because distribution only generates and installs a crap pom, this injects our rectified one
//into maven local
task installDistZipPom(description: 'Install a correct and valid pom for distribution only modules to maven local',
group: 'Publishing') << {
    if (project.isDistribution && !project.isJavaProject){
        //dist only
        createPom("$buildDir/distributions/", "pom-default.xml")
        String groupId = project.group;
        groupId = groupId.replace(".","/");
        File target = new File(System.getProperty("user.home") + "/.m2/repository/" + groupId + "/" + project.name + "/" + project.version + "/" + project.name + "-" + project.version + ".pom");
        //System.out.println("copying from " + buildDir.absolutePath + " " + project.buildDir.absolutePath + "/distributions/" + " to " + t.absolutePath + " ? exists:" + t.exists());


        File srcpom = new File(project.buildDir.absolutePath + "/distributions/pom-default.xml");
        java.nio.file.Files.copy(srcpom.toPath(), target.toPath(),  StandardCopyOption.REPLACE_EXISTING);

        //new File(System.getProperty("user.home") + "/.m2/repository/" + groupId + "/" + project.name + "/" + project.version + "/"+ project.name + "-" + project.version + ".pom").delete()
        /*copy{
            //fun fact buildDir vs project.buildDir can be different on multimodule projects!
            from project.buildDir.absolutePath + "/distributions/"
            include 'pom-default.xml'
            into System.getProperty("user.home") + "/.m2/repository/" + groupId + "/" + project.name + "/" + project.version + "/"
            rename ('pom-default.xml', project.name + "-" + project.version + ".pom")
            eachFile{
            //    System.out.println("Copying...." + it.getPath())
            }
        }*/


    }
}


/**
 * Signs a file via gpg
 * @param file string path to the file
 * @return false is signing failed or gpg is not available
 */
ext.signFile = { file ->
    logger.debug("attempting to sign " + file)
    if (!new File(file).exists()) {
        logger.warn("\n\nWARN - skipping gpg signature of " + file + ", file not found\n\n");
        return false;
    }
    File f = new File(file + ".asc");
    if (f.exists())
        f.delete();


    List<String> arguments = new ArrayList<>();

    ext.gpgSecretKeyRingFile

    ext.gpgPublicKeyring
    arguments.add("-a");    //armor output (ascii encoding)
    arguments.add("--output");
    arguments.add(file + ".asc");

    if (ext.gpgHomeDir!=null && !"".equalsIgnoreCase(ext.gpgHomeDir)){
        arguments.add("--homedir");
        arguments.add(ext.gpgHomeDir);
    }
    if (ext.gpgKeyName!=null && !"".equalsIgnoreCase(ext.gpgKeyName)){
        arguments.add("--local-user");
        arguments.add(ext.gpgKeyName);
    }
    if (ext.gpgPassphrase!=null && !"".equalsIgnoreCase(ext.gpgPassphrase)){
        arguments.add("--batch");
        arguments.add("--passphrase");
        arguments.add(ext.gpgPassphrase);
    }
    if (ext.gpgPassphraseNew!=null && !"".equalsIgnoreCase(ext.gpgPassphraseNew)){
        arguments.add("--batch");
        arguments.add("--passphrase");
        arguments.add(ext.gpgPassphraseNew);
    }
    if (ext.gpgSecretKeyRingFile!=null && !"".equalsIgnoreCase(ext.gpgSecretKeyRingFile)){
        arguments.add("--secret-keyring");
        arguments.add(ext.gpgSecretKeyRingFile);
    }
    /*if (ext.gpgUseAgent){
        arguments.add("--use-agent");
    } else {
        arguments.add("--no-use-agent");
    }*/
    if (!ext.gpgdefaultKeyring){
        arguments.add("--no-default-keyring");
    }
    if (!ext.gpgisInteractive){
        arguments.add("--no-tty");
    }
    arguments.add("--detach-sig");
    arguments.add(file);
    String[] bits = arguments.toArray(new String[arguments.size()]);


    logger.info("\n\nSigning file " + file);

    exec {
        executable ext.gpgPath
        args bits
    }

    return true;
}

/**
 * a simple container for capturing data about a file that needs to be signed
 */
class Container{
    String fileNameAndPath;
    String fileName;
    String artifactId;
    /**
     * only used to diff pom files
     */
    String type;
    String buildDir;
}

/**
 * this bit is kind of interesting
 * when the signing code runs, it tends to run out of order, thiis part will force the signing method
 * to rerun as the rest of the project is built.
 *
 * is it unnecessary work? you bet, however the signer skips
 */
gradle.taskGraph.whenReady { taskGraph ->
    def tasks = taskGraph.getAllTasks()
    tasks.each {
        def taskName = it.getName()
        if (taskName == 'signArtifacts' || taskName == "signArtifacts2" ||
                taskName == "generatePomFileForAndroidArtifactsPublication") {
            logger.debug("Found $taskName")

            it.setOnlyIf { true }
            it.outputs.upToDateWhen { false }
        }
    }
}

void printCurrentDependency(dependenciesNode){
    dependenciesNode.each { item ->

        String itemscope = "compile";
        String itemgroup;
        String itemversion;
        String itemid;

        String crap = item.getProperties().directChildren;
        //gross
        int index = crap.indexOf("value=", crap.indexOf("groupId[["));
        if (index > 0) {
            index += 5
            itemgroup = crap.substring(index + 1, crap.indexOf("]", index));
        }

        index = crap.indexOf("value=", crap.indexOf("scope["));
        if (index > 0) {
            index += 5
            itemscope = crap.substring(index + 1, crap.indexOf("]", index));
        }
        index = crap.indexOf("value=", crap.indexOf("artifactId["));
        if (index > 0) {
            index += 5
            itemid = crap.substring(index + 1, crap.indexOf("]", index));
        }
        index = crap.indexOf("value=", crap.indexOf("version["));
        if (index > 0) {
            index += 5
            itemversion = crap.substring(index + 1, crap.indexOf("]", index));
        }

        System.out.println("===================================");
        System.out.println(itemgroup + ":" + itemid + ":" + itemversion + ":" + itemscope);
        System.out.println("===================================");
    }
}


def reflect(object) {
    Method[] bits = object.class.methods
    for (int k =0; k < bits.length; k++){
        System.out.println("REFLECT " + bits[k].name);
        for (int x= 0; x < bits[k].parameterTypes.length; x++) {
            System.out.println("\t" + bits[k].parameterTypes[x].name);
        }
    }

    //println "REFLECT groovy methods" + object.metaClass.methods*.name.sort().unique()
    object.metaClass.properties.each {println "REFLECT groovy properties"+ it.name }

}


//used to surpress output from pgp's help method
def dummyOutputStream = new OutputStream() {
    @Override
    public void write(int b) {}
}


/**
 * Attempts to call pgp --help
 * @return true
 if gpg is available on the system
 */
def isGPGAvailable(){
    if (project.ext.pgpSearch)
        return project.ext.pgpAvailable;
    project.ext.pgpSearch=true;
    logger.debug("searching for GPG")
    try {
        exec {
            executable ext.gpgPath
            args "--help"
            standardOutput = new ByteArrayOutputStream()
            errorOutput = new ByteArrayOutputStream()
        }
        logger.debug("GPG found at " + gpgPath);
        project.ext.pgpAvailable=true;
        return true;
    }catch (Exception ex){
        ex.printStackTrace();
    }
    //TODO search commons paths for windows?
    logger.warn("GPG NOT found, signing will not be possible");
    project.ext.pgpAvailable=false;
    return false;
}


/**
 * dev note: this function could possibly be used to completely override gradle's publish mechanism
 * by injecting an HTTP PUT, effectively solving the rediciously problem of not being able to specify
 * the name of the artifact when it's uploaded.
 */

task signArtifacts(description: 'Attempts to gpg sign all artifacts to mavenCentral/nexus type repository. Use with\n' +
        '\tgradlew clean\n' +
        '\tgradlew install -Pprofile=sources,javadocs\n' +
        '\tgradlew signArtifacts -Pprofile=sources,javadocs,sign\n', group:"Gradle Fury Crypto") << {

    // this line just makes gradle angry, left as a warn for future self
    // outputs.upToDateWhen { false }
    logger.info("Attempting to sign artifacts "  + project.ext.artifacts.size());

    Iterator<Container> myiterator = project.ext.artifacts.iterator();
    while (myiterator.hasNext()){

        Container item = myiterator.next();
        logger.debug(item.fileNameAndPath + " " + item.fileName + " " + item.type);
        if (item.fileNameAndPath.endsWith(".pom")) {
            if ("jar".equals(item.type)) {

                item.fileNameAndPath = item.buildDir + "/publications/javaArtifacts/pom-default.xml";
            }
            if ("aar".equals(item.type)) {

                item.fileNameAndPath = item.buildDir + "/publications/androidArtifacts/pom-default.xml";
            }
            if ("apk".equals(item.type)) {

                item.fileNameAndPath = item.buildDir + "/publications/androidArtifacts/pom-default.xml";
            }
        }
        if (isGPGAvailable()) {
            if (signFile(item.fileNameAndPath)) {
                logger.info(item.fileNameAndPath + " signed!");
            } else {
                logger.warn("\n\nWARN - failed to sign artifact at " + item.fileNameAndPath + " \n\n");
            }
        } else {
            logger.warn("GPG not available " - item.fileNameAndPath);

        }
    }
}

/**
 * from https://github.com/hwiegard/gradle-checksum-plugin/blob/master/src/main/groovy/com/github/hwiegard/gradle/checksum/ChecksumPlugin.groovy
 * @param file
 * @param algorithm
 * @param length
 * @return
 */
def generateChecksumForFile(File file, String algorithm, int length) {
    MessageDigest digest = MessageDigest.getInstance(algorithm)
    file.withInputStream { is ->
        byte[] buffer = new byte[8192]
        int read
        while ((read = is.read(buffer)) > 0) {
            digest.update(buffer, 0, read)
        }
    }
    byte[] md5sum = digest.digest()
    BigInteger bigInt = new BigInteger(1, md5sum)
    def md5Sum = bigInt.toString(16).padLeft(length, '0')
    //project.logger.debug "Calculated MD5 sum '${md5Sum}' for file '${file}'"
    new File(file.absolutePath + '.' + algorithm.toLowerCase()).write "${md5Sum}"
}

//so why did we have to write this? because gradle....
//android artifact poms would sign but not upload using the standard naming convention
//all of this was just to fix it
task publishArtifacts( description: 'Attempts to publish all artifacts to mavenCentral/nexus type repository. Use with\n' +
        '\tgradlew clean\n' +
        '\tgradlew install -Pprofile=sources,javadocs\n' +
        '\tgradlew publishArtifacts -Pprofile=sources,javadocs,sign\n',
        group: "Gradle Fury Publishing"
        ) << {


    if ((project.ext.skipPublish)) {
        logger.warn("publication of " + project.name + " has been skipped due to configuration");
        return;
    }
    if ("".equalsIgnoreCase(targetRepositoryUrl) || targetRepositoryUrl==null){
        throw new Exception("Cannot publish without a repository url defined");
    }
    if ("".equalsIgnoreCase(project.nexusUsername) || project.nexusUsername==null){
        throw new Exception("Cannot publish without a repository username");
    }
    if ("".equalsIgnoreCase(project.nexusPassword) || project.nexusPassword==null){
        throw new Exception("Cannot publish without a repository password");
    }

    Authenticator.setDefault (new Authenticator() {
        protected PasswordAuthentication getPasswordAuthentication() {
            return new PasswordAuthentication (project.nexusUsername, project.nexusPassword.toCharArray());
        }
    });







    Iterator<Container> myiterator = project.ext.artifacts.iterator();
    while (myiterator.hasNext()) {

        String groupurl = project.group.replace(".", "/");
        Container item = myiterator.next();
        //logger.warn(item.fileNameAndPath + " " + item.fileName + " " + item.type + " " + project.name);
        File f = new File(item.fileNameAndPath);

        String uploadedFileName = f.getName();
        //this part is a hack to work around gradle's strange handling of poms
        if (uploadedFileName.equalsIgnoreCase("pom-default.xml")) {
            uploadedFileName = project.name + "-" + project.version + ".pom"
        }
        //an artifact was added to the list that is a signature, we'll skip it since we sign everything anyhow
        if (uploadedFileName.toLowerCase().endsWith(".asc"))
            continue;
        uploadedFileName=uploadedFileName.replace("-release","");
        uploadedFileName=uploadedFileName.replace("Release","");

        //upload the primart artifact
        if (uploadedFileName.endsWith(".pom"))
            uploadFile(f,targetRepositoryUrl + groupurl + "/" + project.name  + "/" + project.version+ "/" + uploadedFileName , "text/xml; charset=utf-8");
        else
            uploadFile(f,targetRepositoryUrl + groupurl + "/" + project.name  + "/" + project.version+ "/" + uploadedFileName , "application/octet-stream; charset=utf-8");

        if (isGPGAvailable()) {
            //sign hash and upload
            signFile(f.absolutePath)
            uploadFile(new File(f.absolutePath + ".asc"), targetRepositoryUrl + groupurl + "/" + project.name + "/" + project.version + "/" + uploadedFileName + ".asc", "text/plain; charset=utf-8");
            generateChecksumForFile(new File(f.absolutePath + ".asc"), 'MD5', 32)
            generateChecksumForFile(new File(f.absolutePath + ".asc"), 'SHA1', 40)
            uploadFile(new File(f.absolutePath + ".asc.md5"),targetRepositoryUrl + groupurl + "/" + project.name  + "/" + project.version+ "/" + uploadedFileName +".asc.md5", "text/plain; charset=utf-8");
            uploadFile(new File(f.absolutePath + ".asc.sha1"),targetRepositoryUrl + groupurl + "/" + project.name  + "/" + project.version+ "/" + uploadedFileName +".asc.sha1", "text/plain; charset=utf-8");
        }
        //hash the artifact
        generateChecksumForFile(f, 'MD5', 32)
        generateChecksumForFile(f, 'SHA1', 40)

        //upload hashes
        uploadFile(new File(f.absolutePath + ".md5"),targetRepositoryUrl + groupurl + "/" + project.name  + "/" + project.version+ "/" + uploadedFileName +".md5", "text/plain; charset=utf-8");
        uploadFile(new File(f.absolutePath + ".sha1"),targetRepositoryUrl + groupurl + "/" + project.name  + "/" + project.version+ "/" + uploadedFileName +".sha1", "text/plain; charset=utf-8");

    }


}

/**
 * uploads a file to the given url
 * borrowed from <a href="http://stackoverflow.com/questions/11420971/send-a-file-with-a-put-request-using-a-httpurlconnection">here</a>
 * @param input
 * @param urlDestination
 * @param contentType
 * @return
 */
def uploadFile(File input, String urlDestination, String contentType){
    try {
        URL url = new URL(urlDestination);
        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
        connection.setDoOutput(true);
        connection.setRequestMethod("PUT");
        connection.setRequestProperty("Content-Type", contentType);
        connection.setRequestProperty("Content-Length", String.valueOf(input.length()));
        connection.setUseCaches(false);
        connection.setDoOutput(true);
        connection.connect();
        FileInputStream streamFileInputStream = new FileInputStream(input);
        BufferedInputStream streamFileBufferedInputStream = new BufferedInputStream(streamFileInputStream);
        OutputStream outputStream = connection.getOutputStream();
        byte[] streamFileBytes = new byte[4096];
        int bytesRead = 0;
        int totalBytesRead = 0;

        while ((bytesRead = streamFileBufferedInputStream.read(streamFileBytes)) > 0) {
            outputStream.write(streamFileBytes, 0, bytesRead);

            totalBytesRead += bytesRead;
            // notifyListenersOnProgress((double)totalBytesRead / (double)input.length());
        }

        outputStream.flush();
        outputStream.close();

        System.out.println("Upload " + urlDestination + " : " + connection.getResponseCode() + ": " + connection.getResponseMessage());

        connection.disconnect();

        logger.debug("Wrote " + totalBytesRead + " bytes of " + input.length() + ", ratio: " + (double) totalBytesRead / (double) input.length());

        if (connection.getResponseCode() < 200 || connection.getResponseCode() >= 300) {
            printError();
            throw new Exception("unexcepted response code. Published failed. " + connection.getResponseCode() + ": " + connection.getResponseMessage())
        }
    }catch (Exception ex){
        printError();
        throw new Exception("unexcepted exception. Published failed. " + ex.getMessage(), ex);
    }

}

//build.finalizedBy(signArtifacts)
publishArtifacts.mustRunAfter(signArtifacts)


def createPom(String outdir, String filename) {
    logger.info("Generating pom for distzip")
    File overrides = new File("${projectDir}/gradle.properties");
    if (overrides.exists()) {
        logger.info("${projectDir}/gradle.properties exists, apply overrides");
        Properties props = new Properties();
        props.load(new FileInputStream("${projectDir}/gradle.properties"));
        props.each { prop ->
            project.ext.set(prop.key, prop.value)
        }
    }

    new File(outdir).mkdirs();
    def custompom = pom {

        project {
            groupId project.group
            artifactId project.name
            version project.version
            packaging 'zip'

            name = project.getName();


            description = project.getDescription();
            //a description is mandatory for mavenCentral, this injects a placeholder
            if ("".equals(description)) {
                description = "A description should be added in the near future, as soon as I hack time.";
            }

            inceptionYear = project.pom.inceptionYear

        }


    }
    StringWriter sw = new StringWriter();
    custompom.writeTo(sw);
    DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();
    InputSource is = new InputSource();
    is.setCharacterStream(new StringReader(sw.toString()));

    Document doc = db.parse(is);
    //now the hard part, construct all the missing bits from the pom, because gradle shitty DSL
    //only covers the basics when construction a pom. why? who the hell knows. total oversight

    Element root = doc.getDocumentElement();

    //project ulr
    Element projectUrl = doc.createElement("url");
    projectUrl.setTextContent(ext.pom.url);
    root.appendChild(projectUrl);

    //organization
    Element organization = doc.createElement("organization");
    Element org_name = doc.createElement("name");
    org_name.setTextContent(project.pom.organization.name)
    Element org_url = doc.createElement("url");
    org_url.setTextContent(project.pom.organization.url)
    organization.appendChild(org_url)
    organization.appendChild(org_name)
    root.appendChild(organization);

    //repositories
    Element repos = doc.createElement("repositories");
    project.repositories.each {
        if (!it.url.toString().startsWith("file:/")) {
            Element repository = doc.createElement("repository");
            Element id = doc.createElement("id");
            id.setTextContent(it.name)
            Element name = doc.createElement("name");
            name.setTextContent(it.name);
            Element url = doc.createElement("url");
            url.setTextContent(it.url.toString())
            repository.appendChild(id)
            repository.appendChild(name)
            repository.appendChild(url);
            repos.appendChild(repository)
        }
    }
    root.appendChild(repos);

    //licenses
    Element licensesNode = doc.createElement("licenses");

// parse the license list
    if (hasProperty("pom.licenses.license.0.name")) {

        for (def i = 0; hasProperty("pom.licenses.license.${i}.name"); ++i) {
            Element license = doc.createElement("license");
            Element licensename = doc.createElement("name");
            licensename.setTextContent(project.property("pom.licenses.license.${i}.name"))

            Element licenseurl = doc.createElement("url");
            licenseurl.setTextContent(hasProperty("pom.licenses.license.${i}.url")
                    ? project.property("pom.licenses.license.${i}.url") : "")

            Element licensedist = doc.createElement("distribution");
            licensedist.setTextContent(hasProperty("pom.licenses.license.${i}.distribution")
                    ? project.property("pom.licenses.license.${i}.distribution") : "")
            if (licensedist.getTextContent()!=null && licensedist.getTextContent().length()>0)
                license.appendChild(licensedist);
            if (licensename.getTextContent()!=null && licensename.getTextContent().length()>0)
                license.appendChild(licensename);
            if (licenseurl.getTextContent()!=null && licenseurl.getTextContent().length()>0)
                license.appendChild(licenseurl);

            licensesNode.appendChild(license)

        }
    }


    root.appendChild(licensesNode);

// parse the developer list
    ////developers

    if (hasProperty("pom.developers.developer.0.id")) {

        Element developersNode = doc.createElement("developers");
        // parse the roles of each developer
        for (def i = 0; hasProperty("pom.developers.developer.${i}.id"); ++i) {

            Element dev = doc.createElement("developer")

            if (hasProperty("pom.developers.developer.${i}.role.0")) {
                Element roles = doc.createElement("roles");
                for (def j = 0; hasProperty("pom.developers.developer.${i}.role.${j}"); ++j) {
                    Element role = doc.createElement("role");
                    role.setTextContent(project.property("pom.developers.developer.${i}.role.${j}"))
                    roles.appendChild(role);
                }
                dev.appendChild(roles)
            }


            Element devid = doc.createElement("id");
            devid.setTextContent(project.property("pom.developers.developer.${i}.id"))
            dev.appendChild(devid);

            devid = doc.createElement("name");
            devid.setTextContent(hasProperty("pom.developers.developer.${i}.name")
                    ? project.property("pom.developers.developer.${i}.name") : "")
            dev.appendChild(devid);

            devid = doc.createElement("email");
            devid.setTextContent(hasProperty("pom.developers.developer.${i}.email")
                    ? project.property("pom.developers.developer.${i}.email") : "")
            dev.appendChild(devid);

            devid = doc.createElement("organization");
            devid.setTextContent(hasProperty("pom.developers.developer.${i}.organization")
                    ? project.property("pom.developers.developer.${i}.organization") : "")
            dev.appendChild(devid);

            developersNode.appendChild(dev);

        }
        root.appendChild(developersNode)
    }


    String tempurl=null;

    Element group = doc.createElement("issueManagement");
    Element item = doc.createElement("system");
    item.setTextContent(hasProperty('pom.issueManagement.system') ? project.property('pom.issueManagement.system') : "");
    group.appendChild(item)
    item = doc.createElement("url");
    item.setTextContent(hasProperty('pom.issueManagement.url') ? project.property('pom.issueManagement.url') : "");
    group.appendChild(item)
    if (item.getTextContent()!=null && item.getTextContent().length()>0)
        root.appendChild(group);


    group = doc.createElement("ciManagement");
    item = doc.createElement("system");
    item.setTextContent(hasProperty('pom.ciManagement.system') ? project.property('pom.ciManagement.system') : "");
    group.appendChild(item)
    item = doc.createElement("url");
    item.setTextContent(hasProperty('pom.ciManagement.url') ? project.property('pom.ciManagement.url') : "");
    group.appendChild(item)
    if (item.getTextContent()!=null && item.getTextContent().length()>0)
        root.appendChild(group);


    group = doc.createElement("scm");
    item = doc.createElement("url");
    tempurl=hasProperty('pom.scm.url') ? project.property('pom.scm.url') : "";
    item.setTextContent(hasProperty('pom.scm.url') ? project.property('pom.scm.url') : "");
    group.appendChild(item)
    item = doc.createElement("connection");
    item.setTextContent(hasProperty('pom.scm.connection') ? project.property('pom.scm.connection') : "");
    group.appendChild(item)
    item = doc.createElement("developerConnection");
    item.setTextContent(hasProperty('pom.scm.developerConnection')
            ? project.property('pom.scm.developerConnection') : "");
    group.appendChild(item)
    if (tempurl!=null && tempurl.length()>0)
        root.appendChild(group);


    group = doc.createElement("distributionManagement");
    Element site = doc.createElement("site");
    item = doc.createElement("id");
    item.setTextContent(hasProperty('pom.distributionManagement.site.id')
            ? project.property('pom.distributionManagement.site.id') : "")
    site.appendChild(item)
    item = doc.createElement("url");
    item.setTextContent(hasProperty('pom.distributionManagement.site.url')
            ? project.property('pom.distributionManagement.site.url') : "");
    if (item.getTextContent() != null && item.getTextContent().length() > 0) {
        site.appendChild(item);
        group.appendChild(site);
        root.appendChild(group);
    }

    //TODO dependencies and repositories

    //finally write out the xml
    // Use a Transformer for output
    TransformerFactory tFactory =
            TransformerFactory.newInstance();
    tFactory.setAttribute("indent-number", 2);
    javax.xml.transform.Transformer transformer =
            tFactory.newTransformer();
    //pretty print of course, anything less would be uncivilized
    transformer.setOutputProperty(OutputKeys.INDENT, "yes");
    transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");


    DOMSource source = new DOMSource(doc);
    StreamResult result = new StreamResult(new FileOutputStream( outdir+"/"+filename));
    transformer.transform(source, result);
    //reflect(custompom)
}



// crypto support


def  hexToBytes(String s) {
    //return s.getBytes();
    return hexToBytes(s.toCharArray());
}

/**
 * gets the master key
 * @return
 */
def loadKey(){
    String users_home = System.getProperty("user.home");
    users_home = users_home.replace("\\", "/"); // to support all platforms.
    users_home = users_home + "/.gradle/";
    logger.debug("User home dir is " + users_home);
    File gradlehome = new File(users_home);
    //check for existing master key
    File keys = new File(gradlehome.getAbsolutePath() + "/fury-keys.properties");

    if (keys.exists()){
        //defined in rooDir/local.properties file
        Properties properties = new Properties()

            properties.load(keys.newDataInputStream())
            if (properties.containsKey("FURY_MASTER_PASSWORD"))
                return properties.getProperty("FURY_MASTER_PASSWORD");
    }
    //defined in the project gradle.properties file
    if (hasProperty('FURY_MASTER_PASSWORD')){
        return FURY_MASTER_PASSWORD
    }

    return "";
}




def tryDecrypt(String ciphertext){
    //we're using {cipher} so trim off the first and last char
    String textToDecrypt = ciphertext.substring(1, ciphertext.length()-1);
    try {
        String text= decrypt(textToDecrypt, loadKey());
        return text;
    }catch (Exception ex){
        logger.warn("Decryption failure - input text was not encrypted or encrypted with a different key," , ex)
    }
    return ciphertext
}

def decrypt(String ciphertext, String key){
    byte[] raw = hexToBytes(key); //
    SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES");
    Cipher cipher = Cipher.getInstance("AES");
    cipher.init(Cipher.DECRYPT_MODE, skeySpec);
    byte[] original = cipher.doFinal(hexToBytes(ciphertext));
    return new String(original);
}

def  hexToBytes(char[] hex) {
    int length = hex.length / 2;
    byte[] raw = new byte[length];
    for (int i = 0; i < length; i++) {
        int high = Character.digit(hex[i * 2], 16);
        int low = Character.digit(hex[i * 2 + 1], 16);
        int value = (high << 4) | low;
        if (value > 127) {
            value -= 256;
        }
        raw[i] = (byte) value;
    }
    return raw;
}

def mightBeEncrypted(String text){
    if (text==null)
        return false;
    if (text.length()==null)
        return false;
    if (text.startsWith("{") && text.endsWith("}"))
        return true;
    return false;
}





configurations {
    umljavadoc
}

dependencies {
    umljavadoc 'org.umlgraph:umlgraph:5.6.6'
}

def isGraphvizDotAvailable() {

    if (rootProject.hasProperty('isGraphvizDotAvailable')) {
        return rootProject.ext.isGraphvizDotAvailable;
    }
    //if os is mac, return false becasue the DOT build for mac os isn't so great and will cause
    //javadoc failures
    String OS = System.getProperty("os.name", "generic").toLowerCase(Locale.ENGLISH);
    if ((OS.indexOf("mac") >= 0) || (OS.indexOf("darwin") >= 0)) {
        logger.warn("WARN - Graphviz/DOT has some issues with MacOS and may cause javadoc generation to fail. Just a heads up");
    }

    //if opt-in is not set or is false, return false
    if (!project.hasProperty("fury.javadocs.umlgraph.enabled")) {
        logger.info("UML Graph skipped, opt-in setting 'fury.javadocs.umlgraph.enabled' is not set");
        rootProject.ext.isGraphvizDotAvailable=false;
        return false;
    }
    if (project.property("fury.javadocs.umlgraph.enabled")==null) {
        logger.info("UML Graph skipped, opt-in setting 'fury.javadocs.umlgraph.enabled' is not set");
        rootProject.ext.isGraphvizDotAvailable=false;
        return false;
    }
    if (!"true".equalsIgnoreCase(project.property("fury.javadocs.umlgraph.enabled"))){
        logger.info("UML Graph skipped, opt-in setting 'fury.javadocs.umlgraph.enabled' is not set");
        rootProject.ext.isGraphvizDotAvailable=false;
        return false;
    }
    try {
        Runtime rt = Runtime.getRuntime();
        Process proc = rt.exec("dot -?");
        int exitVal = proc.waitFor();

        if (exitVal == 0) {
            logger.info("DOT is available");
            rootProject.ext.isGraphvizDotAvailable=true;
            return true;
        }
    }catch (Exception ex){
        //ex.printStackTrace();
    }

    logger.info("DOT is NOT available");
    rootProject.ext.isGraphvizDotAvailable=false;
    return false;
}


void printError(){
    println "     _.-^^---....,,--\n" +
            " _--                  --_\n" +
            "<                        >)\n" +
            "|                         |\n" +
            " \\._                   _./\n" +
            "    ```--. . , ; .--'''\n" +
            "          | |   |\n" +
            "       .-=||  | |=-.\n" +
            "       `-=#\$%&%\$#=-'\n" +
            "          | ;  :|\n" +
            " _____.,-#%&\$@%#&#~,._____ "
}