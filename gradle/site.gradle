/**
 our attempt at a maven site plugin

 never heard of it? Basically most Apache projects use it
  - https://maven.apache.org/
  - http://maven.apache.org/skins/maven-fluido-skin/
  - http://hadoop.apache.org/

 All of those are 'generated' sites, meaning that most or all of the content is located in the source
 repo of the project and thus stays synced with the code. Everything else, like project reports, etc
 are generated as part of the build process to help you make your code better and to provide full
 disclosure.

 Gradle says they are working on a site plugin, but there hasn't been any activity on it in several years.

 We'd love to reuse doxia, but it is a bit on the complex side and extracting it from maven was attempted
 and proved to be more difficult that writing one from scratch.

 Heavily based on the work done by Paul Speed-2 @ filament
 https://sourceforge.net/p/filament/code/HEAD/tree/trunk/site/build.gradle

 http://maven.apache.org/skins/maven-fluido-skin/

 To apply this to your project
 - Copy the contents from gradle-fury/src/site into your source repo.
 - Make sure the properties file for your project is configured (see fury's for an example)
 - In your root build.gradle file, stick this in the end (not in all projects)

     //this is the gradle-fury site plugin, very similar to the maven site plugin
     apply from 'https://raw.githubusercontent.com/gradle-fury/gradle-fury/master/gradle/site.gradle'

 Then execute it with

 'gradlew site'
 or optionally

 'gradlew siteWar'
 to produce a deployable war file

 @author Alex O'Ree
 */


buildscript{
    repositories {
        jcenter()
        mavenCentral()
        mavenLocal()
    }
    dependencies {
        // https://mvnrepository.com/artifact/org.pegdown/pegdown
        // oom errors classpath 'org.pegdown:pegdown:1.6.0'
        classpath 'com.atlassian.commonmark:commonmark:0.7.0'
        classpath 'com.atlassian.commonmark:commonmark-ext-gfm-tables:0.7.0'
        classpath 'com.atlassian.commonmark:commonmark-ext-gfm-strikethrough:0.7.0'
        classpath 'com.atlassian.commonmark:commonmark-ext-autolink:0.7.0'
        classpath 'org.apache.commons:commons-lang3:3.4'
        classpath 'commons-io:commons-io:2.5'

        //no go classpath 'org.commonjava.googlecode.markdown4j:markdown4j:2.2-cj-1.1'
        classpath "org.jsoup:jsoup:1.9.2"
        classpath 'org.asciidoctor:asciidoctorj:1.5.4'
    }
}

import java.lang.reflect.Method
import java.nio.charset.Charset
import java.nio.file.Files
import java.nio.file.Paths
import org.apache.commons.lang3.StringEscapeUtils;
import org.commonmark.node.*;
import org.commonmark.parser.*;
import org.commonmark.renderer.html.*;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;

import java.text.SimpleDateFormat
import java.util.regex.Matcher
import java.util.regex.Pattern;

if (!hasProperty("buildWebsiteDir")){
    ext.buildWebsiteDir = "${rootDir}/build/site/"
}
ext.webSrcDir = "${rootDir}/src/site/"
ext.javadocsModules = new ArrayList<>();
ext.reports = new ArrayList<>();
ext.webBootstrapUrl = "https://raw.githubusercontent.com/gradle-fury/gradle-fury/master/src/site/";

if (!hasProperty("site.name"))
    ext.setProperty("site.name", rootDir.getName());


configurations {
    umljavadocsite
}

dependencies {
    umljavadocsite 'org.umlgraph:umlgraph:5.6.6'
}


/**
 * bootstraps the site, only ran during the first AND /src/site/template.html doesn't exist
 */
task siteInit(group: "Gradle Fury Site Generation",
        description: 'Initializes the site content structure, if needed.' )  << {



    File site = new File (rootDir.absolutePath + "/src/site/");
    boolean doWork=false;
    if (!site.exists()) {
        logger.info(site.absolutePath + " does not exist");
        //ok work to do
        site.mkdirs();
        doWork=true;
    }
    //other tasks may have created the dirs already
    if (!(new File(site.absolutePath + "/template.html").exists())) {
        logger.info(site.absolutePath + "/template.html" + " does not exist");
        doWork = true;
    }
    if (doWork) {
        //download the latest and greatest from the gradle-fury templates
        logger.warn("Gradle Fury Site Plugin is bootstraping...");
        String file= (project.ext.webBootstrapUrl +"/bootstrap.files").toURL().getText();
        //split the file on the "#" symbol to get lines
        String[] lines = file.split("\n");
        for (int i=0; i < lines.length; i++){
            if (!lines[i].startsWith("#") && lines[i].trim().length()>0) {

                String outputRelativeFile = lines[i].trim().replace(project.ext.webBootstrapUrl, "");
                File outfile = new File(site.absolutePath + "/" + outputRelativeFile);
                if (!outfile.exists()) {
                    logger.warn("Downloading " + lines[i].trim());
                    URL u = new URL(lines[i].trim());
                    URLConnection connection = u.openConnection()
                    InputStream input = connection.getInputStream();
                    byte[] buffer = new byte[4096];
                    int n = -1;
                    String path = (site.absolutePath + "/" + outputRelativeFile);
                    path = path.substring(0, path.lastIndexOf("/"));
                    new File(path).mkdirs();
                    OutputStream output = new FileOutputStream(site.absolutePath + "/" + outputRelativeFile);
                    while ((n = input.read(buffer)) != -1) {
                        output.write(buffer, 0, n);
                    }
                    output.close();
                    input.close();
                }
            }

        }
        if (!(new File(site.absolutePath + "/index.md" ).exists())) {
            String index = '# Welcome to ${site.name}\n\nThis is the home page. Maybe someone will put some useful information here';
            FileOutputStream fos = new FileOutputStream(site.absolutePath + "/index.md");
            fos.write(index.getBytes(Charset.defaultCharset()));
            fos.close()
        }

    } else {
        logger.info("Skipping bootstrap");
    }
}

/**
 * builds the site
 */
task site(group: "Gradle Fury Site Generation",
        description: 'Builds the web-site contents.', dependsOn: siteInit )  << {
    List<File> javadocs = copyJavadocPages(rootDir,true);

    List<File> reportsDocs = copyReports(rootDir,true);

    copyUserSiteSrc();

    generateNavMenu();

    prepareTemplate();

    generateCannedContent(javadocs, reportsDocs);

    int modifiedFiles = convertContent();
    logger.info("Site generation complete, altered " + modifiedFiles + " files");

    new File(project.ext.buildWebsiteDir + "/template.html").delete();

}

/**
 * only used for generating a war file
 */
void createWebXml() {
    new File(project.ext.buildWebsiteDir).mkdirs();
    new File(project.ext.buildWebsiteDir + "/WEB-INF/").mkdirs();
    String contents = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
            "<!DOCTYPE web-app PUBLIC\n" +
            "    \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\"\n" +
            "    \"http://java.sun.com/dtd/web-app_2_3.dtd\">\n" +
            "<web-app>\n" +
            "    <session-config>\n" +
            "        <session-timeout>\n" +
            "            30\n" +
            "        </session-timeout>\n" +
            "    </session-config>\n" +
            "    <welcome-file-list>\n" +
            "        <welcome-file>index.html</welcome-file>\n" +
            "    </welcome-file-list>\n" +
            "</web-app>";
    File file = new File(project.ext.buildWebsiteDir + "WEB-INF/web.xml");
    PrintWriter out = new PrintWriter(file);
    out.println(contents);
    out.close()
}

/**
 * builds the site as a war
 */
task siteWar(group: "Gradle Fury Site Generation",
        description: 'Builds the web-site as a war file.',
        dependsOn:[site])  << {

    createWebXml();
    task(zipResources, type: Zip) {
        destinationDir new File("${rootDir}/build/")
        archiveName 'site.war'
        from project.ext.buildWebsiteDir

    }.execute()

}
siteWar.dependsOn site




def prepareTemplate(){
    long time = System.currentTimeMillis();
    project.ext.siteTemplate = "";
    project.ext.siteTimestamp = time;

    String header = readFile(ext.webSrcDir + "/template.html", Charset.defaultCharset());
    header = preprocessContents(header);
    String fork = getForkMe();
    header = header.replace('${forkMeOnGitHub}', fork);

    //${generatedMenu}
    header = header.replace('${generatedMenu}', project.ext.siteMenu);

    project.ext.siteTemplate = header;

}


int convertContent(){
    return processContent(new File(ext.buildWebsiteDir));
}

int processContent(File directory){
    int count=0;
    File f= directory;
    File[] files = f.listFiles();
    for (int i=0; i < files.length; i++){
        if (files[i].isDirectory()){
            //recurse
            count+=processContent(files[i]);
        } else if (!files[i].isHidden() && files[i].isFile()){
            if (processFile(files[i]))
                count++;
        }
    }
    return count;
}

/**
 * processes a file and performs basic find/replace tasks. This is what injects site templates
 * and whatnot into a file.
 *
 * It also processes non-site contents, such as generated reports by converting absolute paths to relevative one
 * @param file
 * @return returns true if the file was modified, false otherwise
 */
boolean processFile(File file){
    if (file.getName().endsWith(".html") || file.getName().endsWith(".xml") || file.getName().endsWith(".txt")){
        //this bit of trickery removes parent paths from reports, because who wants to know what
        //your local file system looks like when browsing a site
        long start = System.currentTimeMillis();
        String contents = readFile(file.getAbsolutePath(), Charset.defaultCharset());
        contents = contents.replace(rootDir.absolutePath, ".");
        PrintWriter out = new PrintWriter(file);
        out.println(contents);
        out.close()
        logger.info("Transform (remove absolute paths) " + file.getAbsolutePath() + " complete in " + (System.currentTimeMillis() - start) + "ms");
        return true;
    }


    if (file.getName().endsWith(".md") || file.getName().endsWith(".asciidoc")) {
        //read all contents
        //process
        long start = System.currentTimeMillis();

        String contents = readFile(file.getAbsolutePath(), Charset.defaultCharset());

        contents = preprocessContents(contents);

        if (file.getName().toLowerCase().endsWith(".md")) {
            //render it
            List<org.commonmark.Extension> extensions = new ArrayList<>();
            extensions.add(org.commonmark.ext.gfm.tables.TablesExtension.create());
            extensions.add(org.commonmark.ext.gfm.strikethrough.StrikethroughExtension.create());
            extensions.add(org.commonmark.ext.autolink.AutolinkExtension.create());
            Parser parser = Parser.builder().extensions(extensions).postProcessor(new PostProcessor() {
                @Override
                public Node process(Node arg0) {
                    Node n = arg0;
                    while (n != null) {
                        if (arg0 instanceof Link) {
                            Link link = (Link) arg0;
                            String dest = link.getDestination();
                            if (!"".equals(dest) && !dest.startsWith("http://") && !dest.startsWith("https://")) {
                                dest = dest + ".html";
                                link.setDestination(dest);
                            }
                        }
                        process(n.getFirstChild());
                        n= n.getNext();


                    }
                    return arg0;
                }

            }).build();

            //TODO replace [[ with [, the next | with ]( and ]] with .html)

            Node document = parser.parse(contents);
            HtmlRenderer renderer = HtmlRenderer.builder().extensions(extensions).build();
            contents = renderer.render(document);  // "<p>This is <em>Sparta</em></p>\n"

            //inject into the template
            String template = project.ext.siteTemplate;
            contents = template.replace('${body}', contents);

            //save it
            String targetFileName = file.getAbsolutePath();
            targetFileName = targetFileName.substring(0, targetFileName.lastIndexOf(".")) + ".html"

            PrintWriter out = new PrintWriter(targetFileName);
            out.println(contents);
            out.close()
            logger.info("Transform as markdown " + file.getAbsolutePath() + " complete in " + (System.currentTimeMillis() - start) + "ms");
            file.delete();
            return true;
        }
        else if (file.getName().toLowerCase().endsWith(".asciidoc")) {
            org.asciidoctor.Asciidoctor asciidoctor = org.asciidoctor.Asciidoctor.Factory.create();
            Map<String, Object> asciidoctorOptions = org.asciidoctor.OptionsBuilder.options().safe(
                    org.asciidoctor.SafeMode.SAFE)
                    .asMap();
            //render it
            contents = asciidoctor.convert(contents,asciidoctorOptions);

            //inject into template
            String template = project.ext.siteTemplate;
            contents = template.replace('${body}', contents);

            //save it
            String targetFileName = file.getAbsolutePath();
            targetFileName = targetFileName.substring(0,targetFileName.lastIndexOf(".")) + ".html"
            PrintWriter out = new PrintWriter(targetFileName);
            out.println(contents);
            out.close()
            logger.info("Transform as asciidoc " + file.getAbsolutePath() + " complete in " + (System.currentTimeMillis() - start) + "ms");
            file.delete();
            return true;
        }
        //TODO future ascii based documentation formats?

    }
    return false;
}

/**
 * replaces variables ${something} with ext values
 * @param content
 * @return
 */
def preprocessContents(String content){

    Properties p = new Properties();
    p.load(new FileInputStream(rootDir.absolutePath + "/gradle.properties"));
    def iterator = p.entrySet().iterator();
    while (iterator.hasNext()){
        def next = iterator.next();
        content=content.replace('${' + next.getKey() + '}', StringEscapeUtils.escapeHtml4(next.getValue()));
    }
    SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
    content=content.replace('${currentYYYYMMDD}', sdf.format(new Date(project.ext.siteTimestamp)));

    sdf = new SimpleDateFormat("yyyy-MM-dd");
    content=content.replace('${currentYYYY-MM-DD}', sdf.format(new Date(project.ext.siteTimestamp)));


    return content;
}

static String readFile(String path, Charset encoding)
        throws IOException
{
    byte[] encoded = Files.readAllBytes(Paths.get(path));
    return new String(encoded, encoding);
}

def generateNavMenu(){

    StringBuilder sb = new StringBuilder();
    File[] srcs =new File(ext.webSrcDir).listFiles(new FilenameFilter() {
        @Override
        boolean accept(File file, String name) {
            if (name.toLowerCase().endsWith(".html") ||
                    name.toLowerCase().endsWith(".md") ||
                    name.toLowerCase().endsWith(".asciidoc") ||
                    name.toLowerCase().endsWith(".pdf"))
                return true;
            return false;
        }
    });
    if (srcs!=null){
        for (int i=0; i < srcs.length; i++){
            String file = srcs[i].getName();
            if (file.equalsIgnoreCase("template.html"))
                continue;
            if (file.equalsIgnoreCase("index.md"))
                continue;
            //trim off the extension
            file = file.substring(0,file.lastIndexOf("."));
            String name = file;
            name = name.replace("-", " ");
            name = org.apache.commons.lang3.StringUtils.join(
                    org.apache.commons.lang3.StringUtils.splitByCharacterTypeCamelCase(name),' ');
            name = org.apache.commons.lang3.StringUtils.capitalize(name);
            sb.append(" <li>\n" +
                    "\n" +
                    "                                <a href=\"" + file + ".html\" title=\"" + StringEscapeUtils.escapeHtml4(name) + "\">\n" +
                    "                                    <span class=\"none\"></span>\n" +
                    "                                    " + StringEscapeUtils.escapeHtml4(name) + "</a>\n" +
                    "                            </li>" );
        }
    }
    project.ext.siteMenu = sb.toString();

}


def generateTeamList(){
    PrintWriter out;
    String rootdir = ext.buildWebsiteDir;

    //team-list
    StringBuilder team = new StringBuilder();

    team.append('## The Team\n A successful project requires many people to play many roles. Some members write code or documentation, while others are valuable as testers, submitting patches and suggestions.\n' +
            '\n' +
            'The team is comprised of Members and Contributors. Members have direct access to the source of a project and actively evolve the code-base. Contributors improve the project through submission of patches and suggestions to the Members. The number of Contributors to the project is unbounded. Get involved today. All contributions to the project are greatly appreciated.\n\n');

    team.append("## Members\n\n" +
            "The following is a list of developers with commit privileges that have directly contributed to the project in one way or another.\n\n");


    if (hasProperty("pom.developers.developer.0.id")) {
        team.append("| Id | Name | Email | Organization | Roles \n");
        team.append("| --- | --- | --- | --- | --- |\n")

        // parse the roles of each developer
        for (def i = 0; hasProperty("pom.developers.developer.${i}.id"); ++i) {

            team.append("| ").append(StringEscapeUtils.escapeHtml4(project.property("pom.developers.developer.${i}.id")));
            team.append("| ");
            if (hasProperty("pom.developers.developer.${i}.name"))
                team.append(StringEscapeUtils.escapeHtml4(project.property("pom.developers.developer.${i}.name")));
            team.append("| ");
            if (hasProperty("pom.developers.developer.${i}.email"))
                team.append(StringEscapeUtils.escapeHtml4(project.property("pom.developers.developer.${i}.email")));
            team.append("| ");
            if (hasProperty("pom.developers.developer.${i}.organization"))
                team.append(StringEscapeUtils.escapeHtml4(project.property("pom.developers.developer.${i}.organization")));
            team.append("| ");

            if (hasProperty("pom.developers.developer.${i}.role.0")) {

                for (def j = 0; hasProperty("pom.developers.developer.${i}.role.${j}"); ++j) {

                    team.append(StringEscapeUtils.escapeHtml4(project.property("pom.developers.developer.${i}.role.${j}"))).append("<br>");

                }
            }
            team.append("\n");


        }

    }
    else team.append("No one was listed, check gradle.properties");

    team.append("\n\n");
    out = new PrintWriter(rootdir + "/team-list.md");
    out.println(team.toString());
    out.close()
}


def generateJavadocContent(List<File> javadocs){

    PrintWriter out;
    String rootdir = ext.buildWebsiteDir;
    //java docs
    StringBuilder javadocMarkdown = new StringBuilder();

    javadocMarkdown.append('## Javadoc\n Here\'s all the Javadocs generate for the project ${site.name}\n\n');
    javadocMarkdown.append("| Module \t| Javadocs \t|\n");
    javadocMarkdown.append("| ------ \t| -------- \t|\n")
    //String rootdir = ext.buildWebsiteDir;
    for (int i = 0; i < javadocs.size(); i++) {
        File f = javadocs.get(i);
        if (new File(f.getAbsolutePath() + File.separator + "index.html").exists()) {
            String subpath = f.getAbsolutePath().replace(rootdir, "");
            javadocMarkdown.append("| ").append(f.getName()).append(" \t| [Javadocs](").append(subpath + "/index.html").append(") \t|\n");
        } else {
            //we have variants to deal with
            File[] variants = f.listFiles();
            if (variants != null) {
                for (int k = 0; k < variants.length; k++) {
                    File variant = variants[k];
                    if (new File(variant.getAbsolutePath() + File.separator+ "index.html").exists()) {
                        String subpath = variant.getAbsolutePath().replace(rootdir, "");
                        javadocMarkdown.append("| ").append(f.getName()).append(" \t| [").append(variant.getName()).append("](").append(subpath+ File.separator +"index.html").append(") \t |\n");
                    }
                }
            }
        }
    }
    javadocMarkdown.append("\n\n");
    out = new PrintWriter(rootdir + File.separator +"javadoc.md");
    out.println(javadocMarkdown.toString());
    out.close()
}


def generateReportList(List<File> reports){
    PrintWriter out;
    String rootdir = ext.buildWebsiteDir;
	String rootdir2 = rootdir.replace('\\',"/");

    StringBuilder reportsMarkdown = new StringBuilder();

    reportsMarkdown.append('## Project Reports\n Here\'s all the Reports that were generated during the build for the project [${site.name}](${pom.url})\n\n');
    reportsMarkdown.append("| Module \t | Report Type\t| Link | Errors | Warnings \t|\n");
    reportsMarkdown.append("| ------ \t | ------     \t| ---- | --- | --- \t|\n")

    List<ReportsContainer> rpts = scanReports(reports);
    for (int i=0; i < rpts.size(); i++){

        ReportsContainer r = rpts.get(i);

        for (int k=0; k < r.links.size(); k++){
            reportsMarkdown.
                    append("| ").
                    append(r.module).
                    append(" | ").
                    append(org.apache.commons.lang3.StringUtils.capitalize(r.reportType)).
                    append(" \t| ");

            reportsMarkdown.
                    append("<a href=\"javascript:showReport('" + r.links.get(k).url.replace('\\',"/").replace(rootdir2,"./") + "');\">").
                    append(org.apache.commons.lang3.StringUtils.capitalize(r.links.get(k).text)).
                    append("</a> ");
            reportsMarkdown.append(" | " + r.links.get(k).errors);
            reportsMarkdown.append(" | " + r.links.get(k).warnings);
            reportsMarkdown.append(" | \n");
        }


    }

    reportsMarkdown.append("\n\n");
    out = new PrintWriter(rootdir + "/reports.md");
    out.println(reportsMarkdown.toString());
    out.close()
}


class ReportsContainer{
    String module;
    String reportType;
    List<Link> links = new ArrayList<>();

    /**
     *  scans through the list looking for the module and report type, returns if found.
     *  writte primarily to prevent duplicates
     * @param module
     * @param reportType
     * @param items
     * @return an instance of ReportsContainer or null
     */
    static ReportsContainer containsModuleReport(String module, String reportType, List<ReportsContainer> items){
        for (int i=0; i < items.size(); i++){
            if (items.get(i).module.equalsIgnoreCase(module) &&
                    items.get(i).reportType.equalsIgnoreCase(reportType))
                return items.get(i);

        }
        return null;
    }

    static String readFile(String path, Charset encoding)
            throws IOException
    {
        byte[] encoded = Files.readAllBytes(Paths.get(path));
        return new String(encoded, encoding);
    }

    public void analyzeReport(String file, Link link){
        System.out.println("Analyzing report [" + module + "][" + reportType + "][" + link.text + "][" + file + "]" );
        if ("checkstyle".equalsIgnoreCase(reportType)){
            processCheckStyle(file, link);
        } else if ("findbugs".equalsIgnoreCase(reportType)){
            processFindbugs(file, link);
        } else if ("tests".equalsIgnoreCase(reportType)){
            processGradleTestResult(file, link);
        } else if ("lint".equalsIgnoreCase(reportType)){
            processAndroidLint(file, link);
        } else if ("androidtests".equalsIgnoreCase(reportType)){
            processGradleTestResult(file, link);
        } else if ("pmd".equalsIgnoreCase(reportType)){
            processPmdReport(file, link);
        }
        //FIXME dex-count reports
    }


    private void processAndroidLint(String file, Link link){
        String contents = readFile(file, java.nio.charset.Charset.defaultCharset());
        Document doc = Jsoup.parse(contents);
        Pattern p= Pattern.compile("[0-9]+ errors and [0-9]+ warnings found");
        Matcher m = p.matcher(doc.text());
        if (m.find()){

            String item =m.group(0);
            String[] bits=item.split(" ");
            int errors = Integer.parseInt(bits[0]);
            int warns = Integer.parseInt(bits[3]);
            link.errors+=errors;
            link.warnings+=warns;
            System.out.println("Error count: " + errors + " warnings: " + warns);
        } else {
            System.out.println("WARN couldn't analyze lint results, regex patter not found");
        }
    }

    private void processGradleTestResult(String file, Link link){
        String contents = readFile(file, java.nio.charset.Charset.defaultCharset());
        Document doc = Jsoup.parse(contents);
        //find the Summary h3, next (2nd in doc) table, second row, second column is errors

        for (Element table : doc.select("#failures .counter")) {
            String errors = table.text();
            System.out.println("Error count: " + errors);
            link.errors += Integer.parseInt(errors.trim());
            break;
        }

    }

    private void processFindbugs(String file, Link link){
        String contents = readFile(file, java.nio.charset.Charset.defaultCharset());
        Document doc = Jsoup.parse(contents);
        //find the Summary h3, next (2nd in doc) table, second row, second column is errors

        for (Element table : doc.select("table")) {
            int count2=0;
            for (Element tr : table.select("tr")){
                count2++;
                if (count2==2 || count2==3){     //high priority items
                    int count3=0;
                    for (Element td : tr.select("td")){
                        count3++;
                        if (count3==2){
                            String errors = td.text();
                            if (errors==null || errors.trim().length()==0)
                                continue;
                            if (count2==2) {
                                System.out.println("Error count: " + errors);
                                link.errors += Integer.parseInt(errors.trim());
                            } else if (count2==3) {
                                System.out.println("Warnings count: " + errors);
                                link.warnings += Integer.parseInt(errors.trim());
                            }
                        }
                    }
                }
            }
            break;
        }

    }

    private void processPmdReport(String file, Link link){
        String contents = readFile(file, java.nio.charset.Charset.defaultCharset());
        Document doc = Jsoup.parse(contents);

        Element lastRow=null;
        for (Element table : doc.select("table")) {
            //only expecting one table
            //get the last row in the table
            for (Element tr : table.select("tr")){
                lastRow = tr;
            }
            break;
        }
        for (Element td : lastRow.select("td")) {
            //first td's content is the error count
            String errors = td.text();
            System.out.println("Error count: " + errors);
            link.errors+= Integer.parseInt(errors.trim());
            break;
        }

    }

    private void processCheckStyle(String file, Link link){
        String contents = readFile(file, java.nio.charset.Charset.defaultCharset());
        Document doc = Jsoup.parse(contents);
        //find the Summary h3, next (2nd in doc) table, second row, second column is errors
        int count=0;
        for (Element table : doc.select("table")) {
            count++;
            if (count==2){
                int count2=0;
                for (Element tr : table.select("tr")){
                    count2++;
                    if (count2==2){
                        int count3=0;
                        for (Element td : tr.select("td")){
                            count3++;
                            if (count3==2){
                                String errors = td.text();
                                System.out.println("Error count: " + errors);
                                link.errors+= Integer.parseInt(errors.trim());
                                return;
                            }

                        }
                    }
                }
            }
        }

    }

}

class Link{
    String text;
    String url;
    int warnings=0;
    int errors=0;

    public String toString(){
        return "Link: " + text + " " + url;
    }
    public static boolean containsLink(List<Link> links,  Link newlink){
        if (links==null || newlink==null)
            return false;
        for (int i=0; i < links.size(); i++){
            if (links.get(i).text.equalsIgnoreCase(newlink.text) &&
                links.get(i).url.equalsIgnoreCase(newlink.url))
                return true;
        }
        return false;
    }
}

/**
 * this atrocious bit of code is necessary because gradle has 0 governance for storing reports
 *
 * to be honest, it's kind of brittle and because THERE'S NO GOVERNANCE!!! it's kind of hard to
 * guess and whatever the hell report task xyz produces.
 *
 * TODO special handling for findbugs and/or jacoco?
 * @param reports
 * @return
 */
List<ReportsContainer> scanReports(List<String> reports){
    List<ReportsContainer> ret = new ArrayList<>();
    String rootdir = ext.buildWebsiteDir;
	System.out.println("scanning reports in " + rootdir);
	if (File.separator != '/')
		rootdir = rootdir.replace('\\',"/");
    for (int i = 0; i < reports.size(); i++) {
        File f = reports.get(i);
        //f is the module name

        File[] report = f.listFiles();
        if (report != null) {
            for (int k = 0; k < report.length; k++) {
                File test = report[k];
                //i hate that i need to do special handling for everything. f gradle
                if (test.getName().equalsIgnoreCase("findbugs")
                        || test.getName().equalsIgnoreCase("checkstyle")
                        || test.getName().equalsIgnoreCase("pmd")
                        || test.getName().equalsIgnoreCase("owasp")){
                    //get all .html files within the folder 'test' and add to the findbugs reports

                    File[] buggers = test.listFiles(new FilenameFilter() {
                        @Override
                        boolean accept(File file, String s) {
                            return (s.toLowerCase().endsWith(".html"))
                        }
                    });
                    if (buggers!=null){
                        for (int bb=0;bb < buggers.length; bb++){
                            String subpath = buggers[bb].getAbsolutePath().replace(rootdir, "");
                            ReportsContainer r =null;

                            r = ReportsContainer.containsModuleReport(f.getName(), test.getName(), ret);

                            if (r==null){
                                r = new ReportsContainer();
                                r.module = f.getName();
                                r.reportType = test.getName();


                                Link l = new Link();
                                l.text = buggers[bb].getName().substring(0, buggers[bb].getName().lastIndexOf("."));
                                l.url =subpath;
                                r.links.add(l);
                                r.analyzeReport(buggers[bb].getAbsolutePath(),l);
                                ret.add(r);
                            } else {
                                //report already exists, just add a new link
                                Link l = new Link();
                                l.text =  buggers[bb].getName().substring(0, buggers[bb].getName().lastIndexOf("."));
                                l.url =subpath;
                                if (!Link.containsLink(r.links,l)) {
                                    r.links.add(l);
                                    r.analyzeReport(buggers[bb].getAbsolutePath(),l);
                                }
                            }
                        }
                    }

                } else if (test.getName().equalsIgnoreCase("jacoco")){
                    //get all .html files within the folder 'test' and add to the findbugs reports
                    File rpt = new File(test.absolutePath + "/test/html/index.html");
                    if (rpt.exists()) {
                        String subpath = rpt.getAbsolutePath().replace(rootdir, "");
                        ReportsContainer r = null;

                        r = ReportsContainer.containsModuleReport(f.getName(), test.getName(), ret);

                        if (r == null) {
                            r = new ReportsContainer();
                            r.module = f.getName();
                            r.reportType = test.getName();


                            Link l = new Link();
                            l.text = test.getName()
                            l.url = subpath;
                            r.links.add(l);
                            r.analyzeReport(rpt.getAbsolutePath(),l);
                            ret.add(r);
                        } else {
                            //report already exists, just add a new link

                            Link l = new Link();
                            l.text = test.getName()
                            l.url = subpath;
                            if (!Link.containsLink(r.links, l)) {
                                r.links.add(l);
                                r.analyzeReport(rpt.getAbsolutePath(),l);
                            }
                        }
                    }

                } else if (test.getName().endsWith(".html")){

                    String subpath = test.getAbsolutePath().replace(rootdir, "");
                    //these are typically
                    //apk lint reports or any report that just dumps itself in the build/repeorts file, how rude
                    ReportsContainer r =null;
                    if (test.getName().contains("lint-")) {
                        r = ReportsContainer.containsModuleReport(f.getName(), "Lint", ret);
                    } else {
                        r = ReportsContainer.containsModuleReport(f.getName(), test.getName(), ret);
                    }
                    if (r==null){
                        r = new ReportsContainer();
                        r.module = f.getName();
                        if (test.getName().contains("lint-")) {
                            r.reportType = "Lint";
                        } else {
                            r.reportType = test.getName();
                        }
                        Link l = new Link();
                        l.text = test.getName().replace(".html","");
                        l.url =subpath;
                        r.links.add(l);
                        r.analyzeReport(test.getAbsolutePath(),l);
                        ret.add(r);
                    } else {
                        //report already exists, just add a new link
                        Link l = new Link();
                        l.text = test.getName().replace(".html","");
                        l.url =subpath;
                        if (!Link.containsLink(r.links,l)) {
                            r.links.add(l);
                            r.analyzeReport(test.getAbsolutePath(),l);
                        }
                    }

                } else if (test.isDirectory() && new File(test.getAbsolutePath() + "/index.html").exists()) {
                    String subpath = test.getAbsolutePath().replace(rootdir, "");
                    //these are typically jar projects, test results
                    ReportsContainer r =null;

                    r = ReportsContainer.containsModuleReport(f.getName(), test.getName(), ret);

                    if (r==null){
                        r = new ReportsContainer();
                        r.module = f.getName();
                        r.reportType = test.getName();

                        Link l = new Link();
                        l.text = test.getName();
                        l.url =subpath+ "/index.html";
                        r.links.add(l);
                        r.analyzeReport(test.getAbsolutePath()+"/index.html",l);
                        ret.add(r);
                    } else {
                        //report already exists, just add a new link
                        Link l = new Link();
                        l.text = test.getName();
                        l.url =subpath+ "/index.html";
                        if (!Link.containsLink(r.links,l)) {
                            r.links.add(l);
                            r.analyzeReport(test.getAbsolutePath()+"/index.html",l);
                        }
                    }

                } else if (test.isDirectory()) {
                    //these are typically
                    //apks with variants test reports
                    File[] variants = test.listFiles();
                    if (variants!=null){
                        for (int j=0; j < variants.length; j++){
                            File index=new File(variants[j].getAbsolutePath() + "/index.html");
                            if (index.exists()){
                                String subpath = index.getAbsolutePath().replace(rootdir, "");

                                ReportsContainer r =null;

                                r = ReportsContainer.containsModuleReport(f.getName(), test.getName(), ret);

                                if (r==null){
                                    r = new ReportsContainer();
                                    r.module = f.getName();
                                    r.reportType = test.getName();

                                    Link l = new Link();
                                    l.text = variants[j].getName()
                                    l.url =subpath;
                                    r.links.add(l);
                                    r.analyzeReport(index.getAbsolutePath(),l);
                                    ret.add(r);
                                } else {
                                    //report already exists, just add a new link

                                    Link l = new Link();
                                    l.text = variants[j].getName()
                                    l.url =subpath;
                                    if (!Link.containsLink(r.links,l)) {
                                        r.links.add(l);
                                        r.analyzeReport(index.getAbsolutePath(),l);
                                    }

                                }

                            } else if (variants[j].name.equalsIgnoreCase("connected")){
                                //android connected tests. shit. seriously why?
                                //this is for the "all" bit
                                //all/index.html
                                File testrpt = new File(variants[j].absolutePath + "/all/index.html");
                                if (testrpt.exists()){
                                    String subpath = testrpt.getAbsolutePath().replace(rootdir, "");
                                    ReportsContainer r =null;

                                    r = ReportsContainer.containsModuleReport(f.getName(), "AndroidTests", ret);

                                    if (r==null){
                                        r = new ReportsContainer();
                                        r.module = f.getName();
                                        r.reportType = "AndroidTests"

                                        Link l = new Link();
                                        l.text = "All"
                                        l.url =subpath;
                                        r.links.add(l);
                                        r.analyzeReport(testrpt.getAbsolutePath(),l);
                                        ret.add(r);
                                    } else {
                                        //report already exists, just add a new link
                                        Link l = new Link();
                                        l.text = "All"
                                        l.url =subpath;
                                        if (!Link.containsLink(r.links,l)) {
                                            r.links.add(l);
                                            r.analyzeReport(testrpt.getAbsolutePath(),l);
                                        }

                                    }
                                }

                                //this is for the "product flavors" bit
                                //flavors/{name}/index.html
                                File xxx = new File(variants[j].absolutePath + "/flavors/");
                                if (xxx.exists()) {
                                    File[] vars = xxx.listFiles(new FilenameFilter() {
                                        @Override
                                        boolean accept(File file, String s) {
                                            if (file.isDirectory() && !s.equalsIgnoreCase("all"))
                                                return true;
                                            return false;
                                        }
                                    });
                                    if (vars != null) {
                                        for (int x = 0; x < vars.length; x++) {
                                            File idx = new File(vars[x].absolutePath + "/index.html");
                                            if (idx.exists()) {

                                                String subpath = idx.getAbsolutePath().replace(rootdir, "");
                                                ReportsContainer r = null;

                                                r = ReportsContainer.containsModuleReport(f.getName(), "AndroidTests", ret);

                                                if (r == null) {
                                                    r = new ReportsContainer();
                                                    r.module = f.getName();
                                                    r.reportType = "AndroidTests"


                                                    Link l = new Link();
                                                    l.text = vars[x].name
                                                    l.url = subpath;
                                                    r.links.add(l);
                                                    r.analyzeReport(idx.getAbsolutePath(),l);
                                                    ret.add(r);
                                                } else {
                                                    //report already exists, just add a new link
                                                    Link l = new Link();
                                                    l.text = vars[x].name
                                                    l.url = subpath;
                                                    if (!Link.containsLink(r.links, l)) {
                                                        r.links.add(l);
                                                        r.analyzeReport(idx.getAbsolutePath(),l);
                                                    }

                                                }
                                            }
                                        }
                                    }
                                }
                            } else
                                logger.debug(variants[j].getAbsolutePath() + " skipped");
                        }
                    }

                }
            }
        }

    }
    return ret;
}

def generateProjectInfo(){

    PrintWriter out;
    String rootdir = ext.buildWebsiteDir;


    //reportsMarkdown docs
    StringBuilder reportsMarkdown = new StringBuilder();

    reportsMarkdown.append('## Project Information\n This document provides an overview of the various documents and links that are part of this project\'s general information. All of this content is automatically generated by [Gradle-Fury](https://github.com/gradle-fury/gradle-fury) on behalf of the project.\n' +
            '\n\n# Modules\n\n');
    reportsMarkdown.append("| Group | Artifact |  Version | Description | Type | Variants |\n");
    reportsMarkdown.append("| --- | --- | --- | --- | --- | --- |\n")
    subprojects.each { p ->
        //note path has a : prefix


        boolean java=p.plugins.hasPlugin('java');
        boolean distro = p.plugins.hasPlugin('distribution') || p.plugins.hasPlugin('application');
        boolean war = p.plugins.hasPlugin('war');
        boolean aar = p.plugins.hasPlugin('com.android.library')
        boolean apk = p.plugins.hasPlugin('com.android.application')

        String type = "";
        if (war) {
            type += " war ";
        }
        if (aar) {
            type += " aar ";
        }
        if (apk) {
            type += " apk ";
        }
        if (java) {
            type += " jar "
        }
        if (distro){
            type+=" zip "
        }
        String path = p.path;
        path = path.substring(path.lastIndexOf(":")+1);

        reportsMarkdown.append("| " +  StringEscapeUtils.escapeHtml4(p.group) + " | ");

        StringBuilder sb = new StringBuilder();
        //variants
        if (apk || aar){
            def variants

            if (p.android.hasProperty('applicationVariants')) {
                variants = p.android.applicationVariants;
            } else if (p.android.hasProperty('libraryVariants')) {
                variants = p.android.libraryVariants;
            }
            variants.all { variant ->
                sb.append(variant.name).append(" ");
            }
        }


        reportsMarkdown.append("<a href=\"javascript:showModal('" + p.group + "','" + path + "','" + p.version + "','" + type + "','" + sb.toString() + "');\">");
        reportsMarkdown.append( StringEscapeUtils.escapeHtml4(path) + "</a> | " + StringEscapeUtils.escapeHtml4(p.version)  );

        reportsMarkdown.append(" | ").append(StringEscapeUtils.escapeHtml4(p.description)).append(" | ").append(type).append(" | ");

        //variants
        if (apk || aar){
            def variants

            if (p.android.hasProperty('applicationVariants')) {
                variants = p.android.applicationVariants;
            } else if (p.android.hasProperty('libraryVariants')) {
                variants = p.android.libraryVariants;
            }
            variants.all { variant ->

                reportsMarkdown.append(variant.name).append("<br>");
            }
        }
        reportsMarkdown.append("\n");
    }

    reportsMarkdown.append("\n\n");
    out = new PrintWriter(rootdir + "/project-info.md");
    out.println(reportsMarkdown.toString());
    out.close()
}




def reflect(object) {
    Method[] bits = object.class.methods
    for (int k =0; k < bits.length; k++){
        System.out.println("REFLECT " + bits[k].name);
        for (int x= 0; x < bits[k].parameterTypes.length; x++) {
            System.out.println("\t" + bits[k].parameterTypes[x].name);
        }
    }

    //println "REFLECT groovy methods" + object.metaClass.methods*.name.sort().unique()
    object.metaClass.properties.each {println "REFLECT groovy properties"+ it.name }

}



def generateRepositories(){

    //dependency-repos

    PrintWriter out;
    String rootdir = ext.buildWebsiteDir;


    //reportsMarkdown docs
    StringBuilder reportsMarkdown = new StringBuilder();

    reportsMarkdown.append('## Dependency Repositories\n This document provides a listing of repositories this project uses for resolving dependencies. It may be useful to you if you use any of this project\'s dependencies within your own project.\n');
    reportsMarkdown.append('\n\n## Repositories\n\n');
    reportsMarkdown.append("| id | Name \t |  Url |\n");
    reportsMarkdown.append("| ------ \t | ------ \t| ---- \t| \n")
    project.repositories.each {
        if (!it.url.toString().startsWith("file:/")) {
            reportsMarkdown.append(it.name).append(" | ");
            reportsMarkdown.append( it.name).append(" | ");
            reportsMarkdown.append(it.url).append(" \n");
        }

    }




    reportsMarkdown.append("\n\n");
    out = new PrintWriter(rootdir + "/dependency-repos.md");
    out.println(reportsMarkdown.toString());
    out.close()
}



def generateCannedContent(List<File> javadocs, List<File> reports) {
    /*
    done modules list
    TODO repositories
    done artifact list?
    done  issue tracking
    done licenses
    done team
    done source repo
    done  ci/integration
    done reports, might be better to tie these to specific modules?

     */


    generateProjectInfo();
    generateTeamList();
    generateJavadocContent(javadocs);
    generateReportList(reports);
    generateLicenses();
    generateRepositories();




}

def generateLicenses(){
    //pom.licenses.license.0.name
    PrintWriter out;
    String rootdir = ext.buildWebsiteDir;

    //team-list
    StringBuilder team = new StringBuilder();

    team.append('## Overview\n Typically the licenses listed for the project are that of the project itself, and not of dependencies.\n' +
            '\n## Project Licenses\n\n');


    if (hasProperty("pom.licenses.license.0.name")) {
        team.append("| License | Link \t |  Distribution |\n");
        team.append("| ------ \t | ------ \t| ---- |\n")
        for (def i = 0; hasProperty("pom.licenses.license.${i}.name"); ++i) {

            team.append(project.property("pom.licenses.license.${i}.name")).append(" | ");

            if (hasProperty("pom.licenses.license.${i}.url"))
            team.append("[").append(project.property("pom.licenses.license.${i}.url")).append("](").append(project.property("pom.licenses.license.${i}.url")).append(")");
            team.append(" | ");
            team.append((hasProperty("pom.licenses.license.${i}.distribution")
                    ? project.property("pom.licenses.license.${i}.distribution") : ""));
            team.append("\n");
        }
    }
    else team.append("No license was listed, check gradle.properties");

    team.append("\n\n");
    out = new PrintWriter(rootdir + "/project-license.md");
    out.println(team.toString());
    out.close()
}


def copyUserSiteSrc(){
    copy {

        from new File(ext.webSrcDir).absolutePath
        into ext.buildWebsiteDir
    }
}

/**
 * find and replace for all supported variables
 */
def preprocessUserSiteContent(){
    //TODO
}

List<File> copyJavadocPages(File currentDir, boolean firstRun) {

    List<File> ret = new ArrayList<>();
    File[] files = currentDir.listFiles();
    if (files != null) {
        for (int i = 0; i < files.length; i++) {
            if (firstRun && files[i].getAbsolutePath().endsWith("build"))
                continue;
            if (files[i].getAbsolutePath().endsWith("build" + File.separator + "docs" + File.separator + "javadoc")) {
				String[] s2 ;
				if (File.separator == '/')
					s2 = files[i].getAbsolutePath().split(File.separator);
					else 
					s2 = files[i].getAbsolutePath().split('\\\\');
                String module = s2[s2.length-4];
                copy {
                    from files[i].absolutePath
                    into ext.buildWebsiteDir + File.separator+"javadocs" +File.separator+ module
                }
                ret.add(new File(ext.buildWebsiteDir + File.separator+ "javadocs" + File.separator + module));
            } else if ( files[i].getAbsolutePath().contains("build" + File.separator +"javadoc")){
				String[] s2;
				if (File.separator == '/')
					s2 = files[i].getAbsolutePath().split(File.separator);
				else s2 = files[i].getAbsolutePath().split('\\\\');
                String module = s2[s2.length-3];
                copy {
                    from files[i].absolutePath
                    into buildWebsiteDir + File.separator + "javadocs" + File.separator + module
                }
                ret.add(new File(buildWebsiteDir + File.separator + "javadocs" + File.separator + module));
            }
            else if (files[i].isDirectory() &&
                    !files[i].isHidden()) {
                        ret.addAll(copyJavadocPages(files[i],false));
            }
        }
    }
    return ret;
    //search for build/docs/javadoc folders
    //search for build/javadoc/flavorDebug/Release folders
    //search for build/javadoc/debug/release folders
}


//search for build/docs/javadoc folders
//search for build/javadoc/flavorDebug/Release folders
//search for build/javadoc/debug/release folders
List<File> copyReports(File currentDir, boolean firstRun) {

    List<File> ret = new ArrayList<>();
    File[] files = currentDir.listFiles();
    if (files != null) {
        for (int i = 0; i < files.length; i++) {
            if (firstRun && files[i].getAbsolutePath().endsWith("build"))
                continue;
            if (files[i].getAbsolutePath().endsWith("build" + File.separator + "reports")) {
                String[] s2;
				if (File.separator == '/')
					s2 = files[i].getAbsolutePath().split(File.separator );
				else
					s2 = files[i].getAbsolutePath().split('\\\\');
                String module = s2[s2.length-3];
                copy {
                    from files[i].absolutePath
                    into ext.buildWebsiteDir + File.separator + "reports" + File.separator + module
                }
				System.out.println(files[i].getAbsolutePath() + " copied");
                ret.add(new File(ext.buildWebsiteDir + File.separator + "reports" + File.separator + module));
            } else if (files[i].getAbsolutePath().contains("build" + File.separator + "outputs")) {
                    //this part is primarily for apk and aar lint reports
                String[] s2;
				if (File.separator == '/')
					s2 = files[i].getAbsolutePath().split(File.separator);
				else s2 = files[i].getAbsolutePath().split('\\\\');
                String module = s2[s2.length-3];
                copy {
                    from files[i].absolutePath
                    into ext.buildWebsiteDir +File.separator + "reports" +  File.separator + module
                    include '*.html'
                    include 'lint*/**'
                }
                    ret.add(new File(ext.buildWebsiteDir + File.separator+ "reports" + File.separator + module));
			System.out.println(files[i].getAbsolutePath() + " copied android");

            }
            else if (files[i].isDirectory() &&
                    !files[i].isHidden()) {
                //this is for subprojects, grandchildren, etc
                        ret.addAll(copyReports(files[i],false));
            }
        }
    }
    return ret;
}


def getForkMe(){
    Properties p = new Properties();
    p.load(new FileInputStream(rootDir.absolutePath + "/gradle.properties"));


    if (p.containsKey("site.forkMe.enable") &&
        p.getProperty("site.forkMe.enable").equalsIgnoreCase("true") &&
        p.containsKey("pom.scm.url") &&
        p.getProperty("pom.scm.url").contains("https://github.com")){
        return "<a href=\"" + p.getProperty("pom.scm.url") + "\">\n" +
                "    <img style=\"position: absolute; top: 0; right: 0; border: 0; z-index: 10000;\"\n" +
                "    src=\"./img/forkme_right_gray_6d6d6d.png\"\n" +
                "    alt=\"Fork me on GitHub\">\n" +
                "    </a>";
    }
    return "";
}




class DependencyReport{
    List<Dependency> deps= new ArrayList<>();

    public Dependency get(String group, String artifact){
        for (int i=0; i < deps.size(); i++){
            if (deps.get(i).artifactId.equals(artifact) &&
                    deps.get(i).groupId.equals(group))
                    return deps.get(i);
        }
        Dependency r = new Dependency();
        r.groupId=group;
        r.artifactId = artifact;
        //r.type.add(type);
        deps.add(r);
        return r;
    }
}

class Dependency{
    Set<String> project = new HashSet<>();//that using this dependency
    String groupId;
    String artifactId;
    Set<String> version = new HashSet<>()
    Set<String>  type= new HashSet<>()

}


task dependencyReportMd(description: 'Generates a Maven parsable dependency list for the project', group: 'Reporting') << {
    DependencyReport rpt = new DependencyReport();
    int modules=1;



    project.configurations.each { configuration ->
        configuration.allDependencies.each { dependency ->
            if (dependency.group != null && dependency.name != null) {
                Set<String> t =resolveType(this.project, dependency.name, dependency.version)
                Dependency d= rpt.get(dependency.group,dependency.name);
                d.type.addAll(t);
                d.project.add("root")

                d.version.add(dependency.getVersion());
            }
        }
    }

    buildscript.configurations.all.each { configuration ->
        configuration.allDependencies.each { dependency ->
            if (dependency.group != null && dependency.name != null) {
                if (dependency.group != null && dependency.name != null) {
                    Set<String> t =resolveType(this.project, dependency.name, dependency.version)
                    Dependency d= rpt.get(dependency.group,dependency.name);
                    d.type.addAll(t);
                    d.project.add("root buildscript")
                    d.version.add(dependency.getVersion());

                }
            }
        }
    }

    subprojects.findAll{
        modules++;
        it.each {
            it.configurations.each { configuration ->
                configuration.allDependencies.each { dependency ->
                    if (dependency.group != null && dependency.name != null) {
                        Set<String> t =resolveType(it, dependency.name, dependency.version)
                        Dependency d= rpt.get(dependency.group,dependency.name);
                        d.type.addAll(t);
                        d.project.add(it.name)
                        d.version.add(dependency.getVersion());
                    }
                }
            }
        }
    }

    subprojects.findAll{
        it.each {
            it.buildscript.configurations.all.each { configuration ->
                configuration.allDependencies.each { dependency ->
                    if (dependency.group != null && dependency.name != null) {
                        if (dependency.group != null && dependency.name != null) {
                            Set<String> t =resolveType(it, dependency.name, dependency.version)
                            Dependency d= rpt.get(dependency.group,dependency.name);
                            d.type.addAll(t);
                            d.project.add(it.name + " buildscript")
                            d.version.add(dependency.getVersion());
                        }
                    }
                }
            }
        }
    }
    //data collected...

    String rootdir2 = project.ext.buildWebsiteDir;
    new File(rootdir2).mkdirs();
    //produce the report
    File outfile = new File(rootdir2 + "/dependencyReport.md");
    StringBuilder sb = new StringBuilder();
    sb.append("# Dependency Report (Gradle Style) \n\n" +
            "This report is useful to analyze your project's dependencies. If you are familiar with Maven's site plugin, this should look familiar " +
            "(Dependency Convergence Report). In addition, " +
            "if you want to quickly grab all of this projects dependencies and force them to load and cache for use " +
            "offline, you should be able to copy and paste the stuff below into an empty gradle.buid file or for a pom.xml.\n\n");
    sb.append("## Dependency Convergence\n\n");

    sb.append("Dependency Statistics\n\n");
    int NOC=0;
    int NOD=0;
    int NOA=0;
    int NOS=0;
    int NOWC=0;
    for (int i=0; i <rpt.deps.size(); i++){
        NOD++;
        def iterator = rpt.deps.get(i).version.iterator();
        if (rpt.deps.get(i).version.size() > 1)
            NOC+=rpt.deps.get(i).version.size();
        while (iterator.hasNext()){

            if (rpt.deps.get(i).type.isEmpty()){
                NOA++;
            }
            else {
                def iterator2 = rpt.deps.get(i).type.iterator();
                while (iterator2.hasNext()) {
                    iterator2.next();
                    NOA++;  //requires the type classifier
                }
            }

            String version = iterator.next();
            if (version.toLowerCase().contains("-snapshot"))
                NOS++;
            if (version.contains("+"))
                NOWC++;
        }
    }

    int NODNOA = 100;
    if (NOA > 0)
        NODNOA = (int)((NOD/NOA) *100);
    sb.append("|  | |\n")
    sb.append("| --- | --- |\n")

    sb.append("Modules: | " + modules + "\n");
    sb.append("Number of dependencies (NOD): | " + NOD + "\n");
    sb.append("Number of unique artifacts (NOA): | " + NOA + "\n");
    sb.append("Number of version-conflicting artifacts (NOC): | " + NOC + "\n");
    sb.append("Number of SNAPSHOT artifacts (NOS): | " + NOS + "\n");
    sb.append("Number of Wildcard artifacts (NOWC): | " + NOWC + "\n");
    sb.append("Convergence (NOD/NOA):| " + NODNOA + "%\n");
    String readyState= "";
    if (NOS > 0)
        readyState = "You have SNAPSHOT dependencies.<br>";
    if (NODNOA < 100){
        readyState += "You do not have 100 % convergence.";
    }
    sb.append("Ready for release (100 % convergence and no SNAPSHOTS):| ");
    if (readyState.length() > 0)
        sb.append("**Error**<br>").append(readyState);
    else sb.append("Ready");
    sb.append("\n\n");
    if (NOC>0)
        logger.warn("WARN - You have " + NOC + " version conflicting artifacts");
    if (NODNOA<100)
        logger.warn("WARN - You have " + NODNOA + "% dependency convergence.");
    if (NOWC>0)
        logger.warn("WARN - You have " + NOWC + " dependencies with wildcard versions, this will effect the stability of the build.");

       sb.append("## Gradle Dependencies, composite\n\n" +
               "This is a composite of all dependencies for this project. Useful if you need to go offline and want to force all dependencies to download. " +
               "Note: the dependencies listed below are all listed as compile, even though they may not actually be compile dependencies. Also missing is classifiers.\n\n````\n\ndependencies {\n");

       for (int i=0; i <rpt.deps.size(); i++){

           def iterator = rpt.deps.get(i).version.iterator();
           if (rpt.deps.get(i).version.size() > 1)
               sb.append("\n\n//WARN dependency converage flag! Currently used by the modules: " + rpt.deps.get(i).project + "\n");
           while (iterator.hasNext()){
                if (rpt.deps.get(i).type.isEmpty()){

                    sb.append('\tcompile: \'');
                    sb.append(rpt.deps.get(i).groupId + ":");
                    sb.append(rpt.deps.get(i).artifactId + ":");
                    sb.append(iterator.next());
                    sb.append("\'\n");
                } else {
                    def iterator2 = rpt.deps.get(i).type.iterator();
                    while (iterator2.hasNext()) {

                        sb.append('\tcompile: \'');
                        sb.append(rpt.deps.get(i).groupId + ":");
                        sb.append(rpt.deps.get(i).artifactId + ":");
                        sb.append(iterator.next());
                        sb.append("@" + iterator2.next());
                        sb.append("\'\n");
                    }
                }
           }
           if (rpt.deps.get(i).version.size() > 1)
               sb.append("//END WARN dependency converage flag!\n\n    ")
       }
       sb.append('}\n````\n');

          sb.append("## Maven Dependencies, composite\n\n" +
                  "This is a composite of all dependencies for this project. Useful if you need to go offline and want to force all dependencies to download. "+
                  "Note: the dependencies listed below are all listed as compile, even though they may not actually be compile dependencies. Also missing is classifiers.\n\n````\n\n<dependencies>\n");

          for (int i=0; i <rpt.deps.size(); i++){

              def iterator = rpt.deps.get(i).version.iterator();
              if (rpt.deps.get(i).version.size() > 1)
                  sb.append("\n\n<!--WARN dependency converage flag! Currently used by the modules: " + rpt.deps.get(i).project + "-->\n");
              while (iterator.hasNext()){
                  if ( rpt.deps.get(i).type.isEmpty()){
                      sb.append('\t<dependency>\n');
                      sb.append('\t\t<groupId>' + rpt.deps.get(i).groupId + "</groupId>\n");
                      sb.append('\t\t<artifactId>' + rpt.deps.get(i).artifactId + "</artifactId>\n");
                      String version = iterator.next();
                      //a gradle wildcard
                      if ("+".equals(version)) {
                          version = "LATEST"
                      } else if (version.endsWith(".+")) {
                          //the version is something.+
                          version = "[" + version.replace(".+", ",)");
                      } else if (version.endsWith("+")) {
                          version = "[" + version.replace("+", ",)");
                      }
                      sb.append('\t\t<version>' + version + '</version>\n');
                      sb.append("\t</dependency>\n");
                  }else {
                      def iterator2 = rpt.deps.get(i).type.iterator();
                      while (iterator2.hasNext()) {
                          sb.append('\t<dependency>\n');
                          sb.append('\t\t<groupId>' + rpt.deps.get(i).groupId + "</groupId>\n");
                          sb.append('\t\t<artifactId>' + rpt.deps.get(i).artifactId + "</artifactId>\n");
                          String version = iterator.next();
                          //a gradle wildcard
                          if ("+".equals(version)) {
                              version = "LATEST"
                          } else if (version.endsWith(".+")) {
                              //the version is something.+
                              version = "[" + version.replace(".+", ",)");
                          } else if (version.endsWith("+")) {
                              version = "[" + version.replace("+", ",)");
                          }
                          sb.append('\t\t<version>' + version + '</version>\n');
                          sb.append("\t\t<type>" + iterator2.next()).append("</type>\n");
                          sb.append("\t</dependency>\n");
                      }

                  }
              }
              if (rpt.deps.get(i).version.size() > 1)
                  sb.append("<!--END WARN dependency converage flag!-->\n\n    ")

          }
    sb.append('</dependencies>\n````\n');
    FileOutputStream fos = new FileOutputStream(outfile);
    fos.write((sb.toString()).getBytes());
    fos.close();

}

Set<String> resolveType(Project it, String artificat, String version){
    Set<String> ret = new HashSet<>();
        String searcher = artificat + "-" + version;
        it.configurations.findAll { set ->
            set.each { config ->
                // Note to future self
                // this apparently dumps all every jar/aar/war/etc file name of the dependency
                //useful for #21 and getting the type. This was initially written to get a list
                //of all configurationNames since they vary from android/jar/war projects
                if (config.name.startsWith(searcher)) {
                    ret.add(config.name.substring(config.name.lastIndexOf(".")+1));
                }

            }
    }
    return ret;
}


task javadocAggregate(type: Javadoc)  {

    if (!hasProperty("buildWebsiteDir")){
        ext.buildWebsiteDir = "${rootDir}/build/site/"
    }
    destinationDir = new File(project.ext.buildWebsiteDir + "/javadocAll/");
    destinationDir.mkdirs()
    //System.out.println("javadocAggregate output to " + project.ext.buildWebsiteDir)

    outputs.upToDateWhen { false }
    subprojects.each { p ->
        //System.out.println("javadocAggregate " + p.name)
        if (p.hasProperty("sourceSets")) {

            //source sets aren't available at this phase of the build cycle. damnit.
            source += p.sourceSets.main.allJava
            source += p.sourceSets.test.allJava
            System.out.println(p.sourceSets.main.allJava)
            if (p.plugins.hasPlugin('com.android.library') ||p.plugins.hasPlugin('com.android.application') )
            try {
                classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
                classpath.plus(p.files(variant.javaCompile.classpath.files))
                //classpath += p.files(ext.androidJar)
            } catch (Throwable ex) {
                ex.printStackTrace()
            }
        } else {
            FileTree tree = fileTree(dir: p.projectDir.absolutePath + "/src/main/java")
            tree.include '**/*.java'
            source+=tree;

            tree = fileTree(dir: p.projectDir.absolutePath + "/src/androidTest/java")
            tree.include '**/*.java'
            source+=tree;

            tree = fileTree(dir: p.projectDir.absolutePath + "/src/test/java")
            tree.include '**/*.java'
            source+=tree;

            try{
                classpath += p.configurations.compile
            }catch (Exception ex){}
            try{
                classpath += p.configurations.test
            }catch (Exception ex){}
            try{
                classpath += p.configurations.all
            }catch (Exception ex){}
            try {
                classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
            }catch (Exception ex){}

        }

        //reflect(p)

    }


    if (hasProperty("android.compileSdkVersion")) {
        String compileSdk = getProperty("android.compileSdkVersion");
        String jar = ""
        try {
            String csdk = compileSdk
            if (csdk.contains("Google")) {
                try {
                    csdk = csdk.split(":")[2];
                } catch (Exception ex) {
                }
            }

            jar = System.getenv().get("ANDROID_HOME") +
                    "/platforms/android-" + csdk + "/android.jar"

        } catch (Exception ex) {
            ex.printStackTrace()
        }

        File j = new File(jar);
        if (j.exists())
            classpath += project.files(j);


        compileSdk = 'Google Inc.:Google APIs:23';
        jar = ""
        try {
            String csdk = compileSdk
            if (csdk.contains("Google")) {
                try {
                    csdk = csdk.split(":")[2];
                } catch (Exception ex) {
                }
            }

            jar = System.getenv().get("ANDROID_HOME") +
                    "/platforms/android-" + csdk + "/android.jar"

        } catch (Exception ex) {
            ex.printStackTrace()
        }

        j = new File(jar);
        if (j.exists()) {
            classpath += project.files(j);
        }
    }

    //System.out.println("classpath for javadoc is now " + classpath);

    options.charSet 'UTF-8'
    options.docEncoding 'UTF-8'
    options.encoding 'UTF-8'
    options {
        try {
            linksOffline("http://d.android.com/reference",
                    System.getenv().get("ANDROID_HOME") + "/docs/reference")
        } catch (Exception ex) {
        }
        setMemberLevel(JavadocMemberLevel.PACKAGE)
        docEncoding = 'UTF-8'
        encoding = 'UTF-8'
        charSet = 'UTF-8'
    }
    //options.addStringOption('Xdoclint:none', '-quiet')
    //classpath = files(variant.javaCompile.classpath.files) + files(ext.androidJar)
    failOnError false

    if (hasProperty('compileJava.sourceCompatibility') &&
            project.property("compileJava.sourceCompatibility").equals("1.5")) {
        options.links 'http://java.sun.com/j2se/1.5.0/docs/guide/javadoc/doclet/spec'
        options.links 'http://java.sun.com/j2se/1.5/docs/api/'
    } else if (hasProperty('compileJava.sourceCompatibility') &&
            project.property("compileJava.sourceCompatibility").equals("1.6")) {
        options.links 'http://docs.oracle.com/javase/6/docs/api/'
    } else if (hasProperty('compileJava.sourceCompatibility') &&
            project.property("compileJava.sourceCompatibility").equals("1.7")) {
        options.links 'http://docs.oracle.com/javase/7/docs/api/'
    } else if (hasProperty('compileJava.sourceCompatibility') &&
            project.property("compileJava.sourceCompatibility").equals("1.8")) {
        options.links 'http://docs.oracle.com/javase/8/docs/api/'
    }

    if (isGraphvizDotAvailable()) {

        options {
            doclet = 'org.umlgraph.doclet.UmlGraphDoc'
            options.docletpath = rootProject.configurations.umljavadocsite.files.asType(List)
            addStringOption('inferrel')
            addStringOption('inferdep')
            addStringOption('qualify')
            addStringOption('postfixpackage')
            addStringOption('hide=java.*')
            addStringOption('collpackages=java.util.*')
            addStringOption('nodefontsize=9')
            addStringOption('nodefontpackagesize','7')

        }

    }
    exclude '**/BuildConfig.java'
    exclude '**/R.java'
    options {
        setMemberLevel(JavadocMemberLevel.PACKAGE)
    }
}



def isGraphvizDotAvailable() {

    if (rootProject.hasProperty('isGraphvizDotAvailable')) {
        return rootProject.ext.isGraphvizDotAvailable;
    }
    //if os is mac, return false becasue the DOT build for mac os isn't so great and will cause
    //javadoc failures
    String OS = System.getProperty("os.name", "generic").toLowerCase(Locale.ENGLISH);
    if ((OS.indexOf("mac") >= 0) || (OS.indexOf("darwin") >= 0)) {
        logger.warn("WARN - Graphviz/DOT has some issues with MacOS and may cause javadoc generation to fail. Just a heads up");
    }

    //if opt-in is not set or is false, return false
    if (!project.hasProperty("fury.javadocs.umlgraph.enabled")) {
        logger.info("UML Graph skipped, opt-in setting 'fury.javadocs.umlgraph.enabled' is not set");
        rootProject.ext.isGraphvizDotAvailable=false;
        return false;
    }
    if (project.property("fury.javadocs.umlgraph.enabled")==null) {
        logger.info("UML Graph skipped, opt-in setting 'fury.javadocs.umlgraph.enabled' is not set");
        rootProject.ext.isGraphvizDotAvailable=false;
        return false;
    }
    if (!"true".equalsIgnoreCase(project.property("fury.javadocs.umlgraph.enabled"))){
        logger.info("UML Graph skipped, opt-in setting 'fury.javadocs.umlgraph.enabled' is not set");
        rootProject.ext.isGraphvizDotAvailable=false;
        return false;
    }
    try {
        Runtime rt = Runtime.getRuntime();
        Process proc = rt.exec("dot -?");
        int exitVal = proc.waitFor();

        if (exitVal == 0) {
            logger.info("DOT is available");
            rootProject.ext.isGraphvizDotAvailable=true;
            return true;
        }
    }catch (Exception ex){
        //ex.printStackTrace();
    }

    logger.info("DOT is NOT available");
    rootProject.ext.isGraphvizDotAvailable=false;
    return false;
}

task copyJavaDocExtra() << {

    File destinationDir = new File(project.ext.buildWebsiteDir + "/javadocAll/");
    destinationDir.mkdirs()

    subprojects.each { p ->
        File f = new File(p.buildDir.absolutePath + "/../src/main/java");
        if (f.exists()){
            System.out.println(f.absolutePath)
            copy {
                from f.absolutePath
                into destinationDir
                include "**/doc-files/*"
            }
        }


    }

}

site.dependsOn dependencyReportMd
site.dependsOn javadocAggregate
javadocAggregate.finalizedBy copyJavaDocExtra